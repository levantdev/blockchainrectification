function $parcel$exportWildcard(dest, source) { Object.keys(source).forEach(function(key) { if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) { return; } Object.defineProperty(dest, key, { enumerable: true, get: function get()
{ return source[key]; } }); }); return dest; } function $parcel$export(e, n, v, s) { Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true}); } var $parcel$global = typeof globalThis !== 'undefined' ? globalThis : typeof self
!== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {}; var $parcel$modules = {}; var $parcel$inits = {}; var parcelRequire = $parcel$global["parcelRequired76f"]; if (parcelRequire == null) { parcelRequire
= function(id) { if (id in $parcel$modules) { return $parcel$modules[id].exports; } if (id in $parcel$inits) { var init = $parcel$inits[id]; delete $parcel$inits[id]; var module = {id: id, exports: {}}; $parcel$modules[id] = module; init.call(module.exports,
module, module.exports); return module.exports; } var err = new Error("Cannot find module '" + id + "'"); err.code = 'MODULE_NOT_FOUND'; throw err; }; parcelRequire.register = function register(id, init) { $parcel$inits[id] = init; }; $parcel$global["parcelRequired76f"]
= parcelRequire; } parcelRequire.register("hxwDY", function(module, exports) { $parcel$export(module.exports, "popperGenerator", () => (parcelRequire("8iXfp")).popperGenerator); $parcel$export(module.exports, "detectOverflow", () => (parcelRequire("gGcga")).default);
$parcel$export(module.exports, "createPopperBase", () => (parcelRequire("8iXfp")).createPopper); $parcel$export(module.exports, "createPopper", () => (parcelRequire("3tUi5")).createPopper); $parcel$export(module.exports, "createPopperLite", () => (parcelRequire("kznft")).createPopper);
var $1KQnQ = parcelRequire("1KQnQ"); var $e0Om6 = parcelRequire("e0Om6"); var $8iXfp = parcelRequire("8iXfp"); var $gGcga = parcelRequire("gGcga"); var $3tUi5 = parcelRequire("3tUi5"); var $kznft = parcelRequire("kznft"); $parcel$exportWildcard(module.exports,
$1KQnQ); $parcel$exportWildcard(module.exports, $e0Om6); }); parcelRequire.register("1KQnQ", function(module, exports) { $parcel$export(module.exports, "top", () => $1472b89a65155de2$export$1e95b668f3b82d); $parcel$export(module.exports, "bottom", ()
=> $1472b89a65155de2$export$40e543e69a8b3fbb); $parcel$export(module.exports, "right", () => $1472b89a65155de2$export$79ffe56a765070d2); $parcel$export(module.exports, "left", () => $1472b89a65155de2$export$eabcd2c8791e7bf4); $parcel$export(module.exports,
"auto", () => $1472b89a65155de2$export$dfb5619354ba860); $parcel$export(module.exports, "basePlacements", () => $1472b89a65155de2$export$aec2ce47c367b8c3); $parcel$export(module.exports, "start", () => $1472b89a65155de2$export$b3571188c770cc5a); $parcel$export(module.exports,
"end", () => $1472b89a65155de2$export$bd5df0f255a350f8); $parcel$export(module.exports, "clippingParents", () => $1472b89a65155de2$export$390fd549c5303b4d); $parcel$export(module.exports, "viewport", () => $1472b89a65155de2$export$d7b7311ec04a3e8f); $parcel$export(module.exports,
"popper", () => $1472b89a65155de2$export$ae5ab1c730825774); $parcel$export(module.exports, "reference", () => $1472b89a65155de2$export$ca50aac9f3ba507f); $parcel$export(module.exports, "variationPlacements", () => $1472b89a65155de2$export$368f9a87e87fa4e1);
$parcel$export(module.exports, "placements", () => $1472b89a65155de2$export$803cd8101b6c182b); $parcel$export(module.exports, "beforeRead", () => $1472b89a65155de2$export$421679a7c3d56e); $parcel$export(module.exports, "read", () => $1472b89a65155de2$export$aafa59e2e03f2942);
$parcel$export(module.exports, "afterRead", () => $1472b89a65155de2$export$6964f6c886723980); $parcel$export(module.exports, "beforeMain", () => $1472b89a65155de2$export$c65e99957a05207c); $parcel$export(module.exports, "main", () => $1472b89a65155de2$export$f22da7240b7add18);
$parcel$export(module.exports, "afterMain", () => $1472b89a65155de2$export$bab79516f2d662fe); $parcel$export(module.exports, "beforeWrite", () => $1472b89a65155de2$export$8d4d2d70e7d46032); $parcel$export(module.exports, "write", () => $1472b89a65155de2$export$68d8715fc104d294);
$parcel$export(module.exports, "afterWrite", () => $1472b89a65155de2$export$70a6e5159acce2e6); $parcel$export(module.exports, "modifierPhases", () => $1472b89a65155de2$export$d087d3878fdf71d5); var $1472b89a65155de2$export$1e95b668f3b82d = "top"; var
$1472b89a65155de2$export$40e543e69a8b3fbb = "bottom"; var $1472b89a65155de2$export$79ffe56a765070d2 = "right"; var $1472b89a65155de2$export$eabcd2c8791e7bf4 = "left"; var $1472b89a65155de2$export$dfb5619354ba860 = "auto"; var $1472b89a65155de2$export$aec2ce47c367b8c3
= [ $1472b89a65155de2$export$1e95b668f3b82d, $1472b89a65155de2$export$40e543e69a8b3fbb, $1472b89a65155de2$export$79ffe56a765070d2, $1472b89a65155de2$export$eabcd2c8791e7bf4 ]; var $1472b89a65155de2$export$b3571188c770cc5a = "start"; var $1472b89a65155de2$export$bd5df0f255a350f8
= "end"; var $1472b89a65155de2$export$390fd549c5303b4d = "clippingParents"; var $1472b89a65155de2$export$d7b7311ec04a3e8f = "viewport"; var $1472b89a65155de2$export$ae5ab1c730825774 = "popper"; var $1472b89a65155de2$export$ca50aac9f3ba507f = "reference";
var $1472b89a65155de2$export$368f9a87e87fa4e1 = /*#__PURE__*/ $1472b89a65155de2$export$aec2ce47c367b8c3.reduce(function(acc, placement) { return acc.concat([ placement + "-" + $1472b89a65155de2$export$b3571188c770cc5a, placement + "-" + $1472b89a65155de2$export$bd5df0f255a350f8
]); }, []); var $1472b89a65155de2$export$803cd8101b6c182b = /*#__PURE__*/ [].concat($1472b89a65155de2$export$aec2ce47c367b8c3, [ $1472b89a65155de2$export$dfb5619354ba860 ]).reduce(function(acc, placement) { return acc.concat([ placement, placement + "-"
+ $1472b89a65155de2$export$b3571188c770cc5a, placement + "-" + $1472b89a65155de2$export$bd5df0f255a350f8 ]); }, []); // modifiers that need to read the DOM var $1472b89a65155de2$export$421679a7c3d56e = "beforeRead"; var $1472b89a65155de2$export$aafa59e2e03f2942
= "read"; var $1472b89a65155de2$export$6964f6c886723980 = "afterRead"; // pure-logic modifiers var $1472b89a65155de2$export$c65e99957a05207c = "beforeMain"; var $1472b89a65155de2$export$f22da7240b7add18 = "main"; var $1472b89a65155de2$export$bab79516f2d662fe
= "afterMain"; // modifier with the purpose to write to the DOM (or write into a framework state) var $1472b89a65155de2$export$8d4d2d70e7d46032 = "beforeWrite"; var $1472b89a65155de2$export$68d8715fc104d294 = "write"; var $1472b89a65155de2$export$70a6e5159acce2e6
= "afterWrite"; var $1472b89a65155de2$export$d087d3878fdf71d5 = [ $1472b89a65155de2$export$421679a7c3d56e, $1472b89a65155de2$export$aafa59e2e03f2942, $1472b89a65155de2$export$6964f6c886723980, $1472b89a65155de2$export$c65e99957a05207c, $1472b89a65155de2$export$f22da7240b7add18,
$1472b89a65155de2$export$bab79516f2d662fe, $1472b89a65155de2$export$8d4d2d70e7d46032, $1472b89a65155de2$export$68d8715fc104d294, $1472b89a65155de2$export$70a6e5159acce2e6 ]; }); parcelRequire.register("e0Om6", function(module, exports) { $parcel$export(module.exports,
"applyStyles", () => (parcelRequire("aOl9t")).default); $parcel$export(module.exports, "arrow", () => (parcelRequire("kU5lB")).default); $parcel$export(module.exports, "computeStyles", () => (parcelRequire("5ZHwq")).default); $parcel$export(module.exports,
"eventListeners", () => (parcelRequire("jU5vk")).default); $parcel$export(module.exports, "flip", () => (parcelRequire("hMqHB")).default); $parcel$export(module.exports, "hide", () => (parcelRequire("95q7y")).default); $parcel$export(module.exports, "offset",
() => (parcelRequire("lWzyf")).default); $parcel$export(module.exports, "popperOffsets", () => (parcelRequire("cePA2")).default); $parcel$export(module.exports, "preventOverflow", () => (parcelRequire("bxdrS")).default); var $aOl9t = parcelRequire("aOl9t");
var $kU5lB = parcelRequire("kU5lB"); var $5ZHwq = parcelRequire("5ZHwq"); var $jU5vk = parcelRequire("jU5vk"); var $hMqHB = parcelRequire("hMqHB"); var $95q7y = parcelRequire("95q7y"); var $lWzyf = parcelRequire("lWzyf"); var $cePA2 = parcelRequire("cePA2");
var $bxdrS = parcelRequire("bxdrS"); }); parcelRequire.register("aOl9t", function(module, exports) { $parcel$export(module.exports, "default", () => $7deefb3680d4558f$export$2e2bcd8739ae039); var $oKPBf = parcelRequire("oKPBf"); var $93iQ7 = parcelRequire("93iQ7");
// and applies them to the HTMLElements such as popper and arrow function $7deefb3680d4558f$var$applyStyles(_ref) { var state = _ref.state; Object.keys(state.elements).forEach(function(name) { var style = state.styles[name] || {}; var attributes = state.attributes[name]
|| {}; var element = state.elements[name]; // arrow is optional + virtual elements if (!(0, $93iQ7.isHTMLElement)(element) || !(0, $oKPBf.default)(element)) return; // Flow doesn't support to extend this property, but it's the most // effective way to
apply styles to an HTMLElement // $FlowFixMe[cannot-write] Object.assign(element.style, style); Object.keys(attributes).forEach(function(name) { var value = attributes[name]; if (value === false) element.removeAttribute(name); else element.setAttribute(name,
value === true ? "" : value); }); }); } function $7deefb3680d4558f$var$effect(_ref2) { var state = _ref2.state; var initialStyles = { popper: { position: state.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference:
{} }; Object.assign(state.elements.popper.style, initialStyles.popper); state.styles = initialStyles; if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow); return function() { Object.keys(state.elements).forEach(function(name)
{ var element = state.elements[name]; var attributes = state.attributes[name] || {}; var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them var
style = styleProperties.reduce(function(style, property) { style[property] = ""; return style; }, {}); // arrow is optional + virtual elements if (!(0, $93iQ7.isHTMLElement)(element) || !(0, $oKPBf.default)(element)) return; Object.assign(element.style,
style); Object.keys(attributes).forEach(function(attribute) { element.removeAttribute(attribute); }); }); }; } // eslint-disable-next-line import/no-unused-modules var $7deefb3680d4558f$export$2e2bcd8739ae039 = { name: "applyStyles", enabled: true, phase:
"write", fn: $7deefb3680d4558f$var$applyStyles, effect: $7deefb3680d4558f$var$effect, requires: [ "computeStyles" ] }; }); parcelRequire.register("oKPBf", function(module, exports) { $parcel$export(module.exports, "default", () => $04a691b7a330df44$export$2e2bcd8739ae039);
function $04a691b7a330df44$export$2e2bcd8739ae039(element) { return element ? (element.nodeName || "").toLowerCase() : null; } }); parcelRequire.register("93iQ7", function(module, exports) { $parcel$export(module.exports, "isElement", () => $69730206aa270d41$export$45a5e7f76e0caa8d);
$parcel$export(module.exports, "isHTMLElement", () => $69730206aa270d41$export$1b3bfaa9684536aa); $parcel$export(module.exports, "isShadowRoot", () => $69730206aa270d41$export$af51f0f06c0f328a); var $93G53 = parcelRequire("93G53"); function $69730206aa270d41$export$45a5e7f76e0caa8d(node)
{ var OwnElement = (0, $93G53.default)(node).Element; return node instanceof OwnElement || node instanceof Element; } function $69730206aa270d41$export$1b3bfaa9684536aa(node) { var OwnElement = (0, $93G53.default)(node).HTMLElement; return node instanceof
OwnElement || node instanceof HTMLElement; } function $69730206aa270d41$export$af51f0f06c0f328a(node) { // IE 11 has no ShadowRoot if (typeof ShadowRoot === "undefined") return false; var OwnElement = (0, $93G53.default)(node).ShadowRoot; return node
instanceof OwnElement || node instanceof ShadowRoot; } }); parcelRequire.register("93G53", function(module, exports) { $parcel$export(module.exports, "default", () => $6985093033570817$export$2e2bcd8739ae039); function $6985093033570817$export$2e2bcd8739ae039(node)
{ if (node == null) return window; if (node.toString() !== "[object Window]") { var ownerDocument = node.ownerDocument; return ownerDocument ? ownerDocument.defaultView || window : window; } return node; } }); parcelRequire.register("kU5lB", function(module,
exports) { $parcel$export(module.exports, "default", () => $f37d2f7eaf2ad10e$export$2e2bcd8739ae039); var $h06jI = parcelRequire("h06jI"); var $dElKO = parcelRequire("dElKO"); var $ciq1x = parcelRequire("ciq1x"); var $5KzeH = parcelRequire("5KzeH"); var
$g1hRA = parcelRequire("g1hRA"); var $cOvrb = parcelRequire("cOvrb"); var $3Os63 = parcelRequire("3Os63"); var $hdgde = parcelRequire("hdgde"); var $1KQnQ = parcelRequire("1KQnQ"); var $f37d2f7eaf2ad10e$var$toPaddingObject = function toPaddingObject(padding,
state) { padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, { placement: state.placement })) : padding; return (0, $3Os63.default)(typeof padding !== "number" ? padding : (0, $hdgde.default)(padding, (0, $1KQnQ.basePlacements)));
}; function $f37d2f7eaf2ad10e$var$arrow(_ref) { var _state$modifiersData$; var state = _ref.state, name = _ref.name, options = _ref.options; var arrowElement = state.elements.arrow; var popperOffsets = state.modifiersData.popperOffsets; var basePlacement
= (0, $h06jI.default)(state.placement); var axis = (0, $g1hRA.default)(basePlacement); var isVertical = [ (0, $1KQnQ.left), (0, $1KQnQ.right) ].indexOf(basePlacement) >= 0; var len = isVertical ? "height" : "width"; if (!arrowElement || !popperOffsets)
return; var paddingObject = $f37d2f7eaf2ad10e$var$toPaddingObject(options.padding, state); var arrowRect = (0, $dElKO.default)(arrowElement); var minProp = axis === "y" ? (0, $1KQnQ.top) : (0, $1KQnQ.left); var maxProp = axis === "y" ? (0, $1KQnQ.bottom)
: (0, $1KQnQ.right); var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len]; var startDiff = popperOffsets[axis] - state.rects.reference[axis]; var arrowOffsetParent = (0, $5KzeH.default)(arrowElement);
var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0; var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point
is // outside of the popper bounds var min = paddingObject[minProp]; var max = clientSize - arrowRect[len] - paddingObject[maxProp]; var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference; var offset = (0, $cOvrb.within)(min, center, max);
// Prevents breaking syntax highlighting... var axisProp = axis; state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$); } function
$f37d2f7eaf2ad10e$var$effect(_ref2) { var state = _ref2.state, options = _ref2.options; var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element; if (arrowElement == null) return; //
CSS selector if (typeof arrowElement === "string") { arrowElement = state.elements.popper.querySelector(arrowElement); if (!arrowElement) return; } if (!(0, $ciq1x.default)(state.elements.popper, arrowElement)) return; state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules var $f37d2f7eaf2ad10e$export$2e2bcd8739ae039 = { name: "arrow", enabled: true, phase: "main", fn: $f37d2f7eaf2ad10e$var$arrow, effect: $f37d2f7eaf2ad10e$var$effect, requires: [ "popperOffsets" ],
requiresIfExists: [ "preventOverflow" ] }; }); parcelRequire.register("h06jI", function(module, exports) { $parcel$export(module.exports, "default", () => $c6075629d0814627$export$2e2bcd8739ae039); function $c6075629d0814627$export$2e2bcd8739ae039(placement)
{ return placement.split("-")[0]; } }); parcelRequire.register("dElKO", function(module, exports) { $parcel$export(module.exports, "default", () => $9effe2b32f662e4a$export$2e2bcd8739ae039); var $41Z5W = parcelRequire("41Z5W"); function $9effe2b32f662e4a$export$2e2bcd8739ae039(element)
{ var clientRect = (0, $41Z5W.default)(element); // Use the clientRect sizes if it's not been transformed. // Fixes https://github.com/popperjs/popper-core/issues/1223 var width = element.offsetWidth; var height = element.offsetHeight; if (Math.abs(clientRect.width
- width)
<=1 ) width=c lientRect.width; if (Math.abs(clientRect.height - height) <=1 ) height=c lientRect.height; return { x: element.offsetLeft, y: element.offsetTop, width: width, height: height }; } }); parcelRequire.register( "41Z5W", function(module,
    exports) { $parcel$export(module.exports, "default", ()=> $2ef6a598263dba8e$export$2e2bcd8739ae039); var $93iQ7 = parcelRequire("93iQ7"); var $4J8n1 = parcelRequire("4J8n1"); var $93G53 = parcelRequire("93G53"); var $gotNd = parcelRequire("gotNd"); function $2ef6a598263dba8e$export$2e2bcd8739ae039(element, includeScale,
    isFixedStrategy) { if (includeScale === void 0) includeScale = false; if (isFixedStrategy === void 0) isFixedStrategy = false; var clientRect = element.getBoundingClientRect(); var scaleX = 1; var scaleY = 1; if (includeScale && (0, $93iQ7.isHTMLElement)(element))
    { scaleX = element.offsetWidth > 0 ? (0, $4J8n1.round)(clientRect.width) / element.offsetWidth || 1 : 1; scaleY = element.offsetHeight > 0 ? (0, $4J8n1.round)(clientRect.height) / element.offsetHeight || 1 : 1; } var _ref = (0, $93iQ7.isElement)(element)
    ? (0, $93G53.default)(element) : window, visualViewport = _ref.visualViewport; var addVisualOffsets = !(0, $gotNd.default)() && isFixedStrategy; var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY; var width = clientRect.width / scaleX; var height = clientRect.height / scaleY; return { width: width, height: height, top: y, right: x + width,
    bottom: y + height, left: x, x: x, y: y }; } }); parcelRequire.register("4J8n1", function(module, exports) { $parcel$export(module.exports, "max", () => $3711db8b00de96df$export$8960430cfd85939f); $parcel$export(module.exports, "min", () => $3711db8b00de96df$export$96ec731ed4dcb222);
    $parcel$export(module.exports, "round", () => $3711db8b00de96df$export$2077e0241d6afd3c); var $3711db8b00de96df$export$8960430cfd85939f = Math.max; var $3711db8b00de96df$export$96ec731ed4dcb222 = Math.min; var $3711db8b00de96df$export$2077e0241d6afd3c
    = Math.round; }); parcelRequire.register("gotNd", function(module, exports) { $parcel$export(module.exports, "default", () => $bef5ff765617d084$export$2e2bcd8739ae039); var $9r1ut = parcelRequire("9r1ut"); function $bef5ff765617d084$export$2e2bcd8739ae039()
    { return !/^((?!chrome|android).)*safari/i.test((0, $9r1ut.default)()); } }); parcelRequire.register("9r1ut", function(module, exports) { $parcel$export(module.exports, "default", () => $6de7caa8ee90d63c$export$2e2bcd8739ae039); function $6de7caa8ee90d63c$export$2e2bcd8739ae039()
    { var uaData = navigator.userAgentData; if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) return uaData.brands.map(function(item) { return item.brand + "/" + item.version; }).join(" "); return navigator.userAgent; } }); parcelRequire.register("ciq1x",
    function(module, exports) { $parcel$export(module.exports, "default", () => $8f3b5a3db2e59cbc$export$2e2bcd8739ae039); var $93iQ7 = parcelRequire("93iQ7"); function $8f3b5a3db2e59cbc$export$2e2bcd8739ae039(parent, child) { var rootNode = child.getRootNode
    && child.getRootNode(); // First, attempt with faster native method if (parent.contains(child)) return true; else if (rootNode && (0, $93iQ7.isShadowRoot)(rootNode)) { var next = child; do { if (next && parent.isSameNode(next)) return true; // $FlowFixMe[prop-missing]:
    need a better way to handle this... next = next.parentNode || next.host; }while (next); } // Give up, the result is false return false; } }); parcelRequire.register("5KzeH", function(module, exports) { $parcel$export(module.exports, "default", ()
    => $42fc94c94931c781$export$2e2bcd8739ae039); var $93G53 = parcelRequire("93G53"); var $oKPBf = parcelRequire("oKPBf"); var $huVQQ = parcelRequire("huVQQ"); var $93iQ7 = parcelRequire("93iQ7"); var $lKbxe = parcelRequire("lKbxe"); var $aerap = parcelRequire("aerap");
    var $9r1ut = parcelRequire("9r1ut"); function $42fc94c94931c781$var$getTrueOffsetParent(element) { if (!(0, $93iQ7.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837 (0, $huVQQ.default)(element).position === "fixed")
    return null; return element.offsetParent; } // `.offsetParent` reports `null` for fixed elements, while absolute elements // return the containing block function $42fc94c94931c781$var$getContainingBlock(element) { var isFirefox = /firefox/i.test((0,
    $9r1ut.default)()); var isIE = /Trident/i.test((0, $9r1ut.default)()); if (isIE && (0, $93iQ7.isHTMLElement)(element)) { // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport var elementCss = (0, $huVQQ.default)(element);
    if (elementCss.position === "fixed") return null; } var currentNode = (0, $aerap.default)(element); if ((0, $93iQ7.isShadowRoot)(currentNode)) currentNode = currentNode.host; while((0, $93iQ7.isHTMLElement)(currentNode) && [ "html", "body" ].indexOf((0,
    $oKPBf.default)(currentNode))
    < 0){ var css=( 0, $huVQQ.default)(currentNode); // This is non-exhaustive but covers the most common CSS properties that // create a containing block. // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !=="none" || css.perspective !=="none" || css.contain==="paint" || [ "transform", "perspective" ].indexOf(css.willChange) !==- 1 || isFirefox && css.willChange==="filter" || isFirefox && css.filter && css.filter !=="none" ) return
        currentNode; else currentNode=c urrentNode.parentNode; } return null; } // Gets the closest ancestor positioned element. Handles some edge cases, function $42fc94c94931c781$export$2e2bcd8739ae039(element) { var window=( 0, $93G53.default)(element);
        var offsetParent=$ 42fc94c94931c781$var$getTrueOffsetParent(element); while(offsetParent && (0, $lKbxe.default)(offsetParent) && (0, $huVQQ.default)(offsetParent).position==="static" )offsetParent=$ 42fc94c94931c781$var$getTrueOffsetParent(offsetParent);
        if (offsetParent && ((0, $oKPBf.default)(offsetParent)==="html" || (0, $oKPBf.default)(offsetParent)==="body" && (0, $huVQQ.default)(offsetParent).position==="static" )) return window; return offsetParent || $42fc94c94931c781$var$getContainingBlock(element)
        || window; } }); parcelRequire.register( "huVQQ", function(module, exports) { $parcel$export(module.exports, "default", ()=> $cbd21d1454570861$export$2e2bcd8739ae039); var $93G53 = parcelRequire("93G53"); function $cbd21d1454570861$export$2e2bcd8739ae039(element) { return (0, $93G53.default)(element).getComputedStyle(element); } }); parcelRequire.register("lKbxe", function(module,
        exports) { $parcel$export(module.exports, "default", () => $fd46d779ec622be4$export$2e2bcd8739ae039); var $oKPBf = parcelRequire("oKPBf"); function $fd46d779ec622be4$export$2e2bcd8739ae039(element) { return [ "table", "td", "th" ].indexOf((0,
        $oKPBf.default)(element)) >= 0; } }); parcelRequire.register("aerap", function(module, exports) { $parcel$export(module.exports, "default", () => $773048fc1d2aa7ee$export$2e2bcd8739ae039); var $oKPBf = parcelRequire("oKPBf"); var $17OuU = parcelRequire("17OuU");
        var $93iQ7 = parcelRequire("93iQ7"); function $773048fc1d2aa7ee$export$2e2bcd8739ae039(element) { if ((0, $oKPBf.default)(element) === "html") return element; return(// $FlowFixMe[incompatible-return] // $FlowFixMe[prop-missing] element.assignedSlot
        || // step into the shadow DOM of the parent of a slotted node element.parentNode || ((0, $93iQ7.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected // $FlowFixMe[incompatible-call]: HTMLElement is a Node (0, $17OuU.default)(element)
        // fallback ); } }); parcelRequire.register("17OuU", function(module, exports) { $parcel$export(module.exports, "default", () => $0d1d9daad62fa952$export$2e2bcd8739ae039); var $93iQ7 = parcelRequire("93iQ7"); function $0d1d9daad62fa952$export$2e2bcd8739ae039(element)
        { // $FlowFixMe[incompatible-return]: assume body is always available return (((0, $93iQ7.isElement)(element) ? element.ownerDocument : element.document) || window.document).documentElement; } }); parcelRequire.register("g1hRA", function(module,
        exports) { $parcel$export(module.exports, "default", () => $ba9a98a4204389e3$export$2e2bcd8739ae039); function $ba9a98a4204389e3$export$2e2bcd8739ae039(placement) { return [ "top", "bottom" ].indexOf(placement) >= 0 ? "x" : "y"; } }); parcelRequire.register("cOvrb",
        function(module, exports) { $parcel$export(module.exports, "within", () => $95428a5e75015184$export$f28d906d67a997f3); $parcel$export(module.exports, "withinMaxClamp", () => $95428a5e75015184$export$86c8af6d3ef0b4a); var $4J8n1 = parcelRequire("4J8n1");
        function $95428a5e75015184$export$f28d906d67a997f3(min, value, max) { return (0, $4J8n1.max)(min, (0, $4J8n1.min)(value, max)); } function $95428a5e75015184$export$86c8af6d3ef0b4a(min, value, max) { var v = $95428a5e75015184$export$f28d906d67a997f3(min,
        value, max); return v > max ? max : v; } }); parcelRequire.register("3Os63", function(module, exports) { $parcel$export(module.exports, "default", () => $2c6bd604be4c867e$export$2e2bcd8739ae039); var $gcu3h = parcelRequire("gcu3h"); function $2c6bd604be4c867e$export$2e2bcd8739ae039(paddingObject)
        { return Object.assign({}, (0, $gcu3h.default)(), paddingObject); } }); parcelRequire.register("gcu3h", function(module, exports) { $parcel$export(module.exports, "default", () => $bcb51404109b5184$export$2e2bcd8739ae039); function $bcb51404109b5184$export$2e2bcd8739ae039()
        { return { top: 0, right: 0, bottom: 0, left: 0 }; } }); parcelRequire.register("hdgde", function(module, exports) { $parcel$export(module.exports, "default", () => $c88039fe47959ef5$export$2e2bcd8739ae039); function $c88039fe47959ef5$export$2e2bcd8739ae039(value,
        keys) { return keys.reduce(function(hashMap, key) { hashMap[key] = value; return hashMap; }, {}); } }); parcelRequire.register("5ZHwq", function(module, exports) { $parcel$export(module.exports, "default", () => $45d468ca92a1d24b$export$2e2bcd8739ae039);
        var $1KQnQ = parcelRequire("1KQnQ"); var $5KzeH = parcelRequire("5KzeH"); var $93G53 = parcelRequire("93G53"); var $17OuU = parcelRequire("17OuU"); var $huVQQ = parcelRequire("huVQQ"); var $h06jI = parcelRequire("h06jI"); var $7kchx = parcelRequire("7kchx");
        var $4J8n1 = parcelRequire("4J8n1"); var $45d468ca92a1d24b$var$unsetSides = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; // Round the offsets to the nearest suitable subpixel based on the DPR. // Zooming can change the DPR, but
        it seems to report a value that will // cleanly divide the values into the appropriate subpixels. function $45d468ca92a1d24b$var$roundOffsetsByDPR(_ref, win) { var x = _ref.x, y = _ref.y; var dpr = win.devicePixelRatio || 1; return { x: (0, $4J8n1.round)(x
        * dpr) / dpr || 0, y: (0, $4J8n1.round)(y * dpr) / dpr || 0 }; } function $45d468ca92a1d24b$export$378fa78a8fea596f(_ref2) { var _Object$assign2; var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation
        = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed; var _offsets$x = offsets.x, x = _offsets$x ===
        void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y; var _ref3 = typeof roundOffsets === "function" ? roundOffsets({ x: x, y: y }) : { x: x, y: y }; x = _ref3.x; y = _ref3.y; var hasX = offsets.hasOwnProperty("x");
        var hasY = offsets.hasOwnProperty("y"); var sideX = (0, $1KQnQ.left); var sideY = (0, $1KQnQ.top); var win = window; if (adaptive) { var offsetParent = (0, $5KzeH.default)(popper); var heightProp = "clientHeight"; var widthProp = "clientWidth";
        if (offsetParent === (0, $93G53.default)(popper)) { offsetParent = (0, $17OuU.default)(popper); if ((0, $huVQQ.default)(offsetParent).position !== "static" && position === "absolute") { heightProp = "scrollHeight"; widthProp = "scrollWidth"; }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it offsetParent; if (placement === (0, $1KQnQ.top) || (placement === (0, $1KQnQ.left) || placement === (0, $1KQnQ.right))
        && variation === (0, $1KQnQ.end)) { sideY = (0, $1KQnQ.bottom); var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp]; y -= offsetY - popperRect.height; y *= gpuAcceleration
        ? 1 : -1; } if (placement === (0, $1KQnQ.left) || (placement === (0, $1KQnQ.top) || placement === (0, $1KQnQ.bottom)) && variation === (0, $1KQnQ.end)) { sideX = (0, $1KQnQ.right); var offsetX = isFixed && offsetParent === win && win.visualViewport
        ? win.visualViewport.width : offsetParent[widthProp]; x -= offsetX - popperRect.width; x *= gpuAcceleration ? 1 : -1; } } var commonStyles = Object.assign({ position: position }, adaptive && $45d468ca92a1d24b$var$unsetSides); var _ref4 = roundOffsets
        === true ? $45d468ca92a1d24b$var$roundOffsetsByDPR({ x: x, y: y }, (0, $93G53.default)(popper)) : { x: x, y: y }; x = _ref4.x; y = _ref4.y; if (gpuAcceleration) { var _Object$assign; return Object.assign({}, commonStyles, (_Object$assign = {},
        _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1)
        <=1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
            } return Object.assign({}, commonStyles, (_Object$assign2={ }, _Object$assign2[sideY]=h asY ? y + "px" : "", _Object$assign2[sideX]=h asX ? x + "px" : "", _Object$assign2.transform="" , _Object$assign2)); } function $45d468ca92a1d24b$var$computeStyles(_ref5)
            { var state=_ ref5.state, options=_ ref5.options; var _options$gpuAccelerat=o ptions.gpuAcceleration, gpuAcceleration=_ options$gpuAccelerat===v oid 0 ? true : _options$gpuAccelerat, _options$adaptive=o ptions.adaptive, adaptive=_ options$adaptive===v
            oid 0 ? true : _options$adaptive, _options$roundOffsets=o ptions.roundOffsets, roundOffsets=_ options$roundOffsets===v oid 0 ? true : _options$roundOffsets; var commonStyles={ placement: (0, $h06jI.default)(state.placement), variation: (0, $7kchx.default)(state.placement),
            popper: state.elements.popper, popperRect: state.rects.popper, gpuAcceleration: gpuAcceleration, isFixed: state.options.strategy==="fixed" }; if (state.modifiersData.popperOffsets !=n ull) state.styles.popper=O bject.assign({}, state.styles.popper,
            $45d468ca92a1d24b$export$378fa78a8fea596f(Object.assign({}, commonStyles, { offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive: adaptive, roundOffsets: roundOffsets }))); if (state.modifiersData.arrow !=n ull)
            state.styles.arrow=O bject.assign({}, state.styles.arrow, $45d468ca92a1d24b$export$378fa78a8fea596f(Object.assign({}, commonStyles, { offsets: state.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: roundOffsets }))); state.attributes.popper=O
            bject.assign({}, state.attributes.popper, { "data-popper-placement": state.placement }); } // eslint-disable-next-line import/no-unused-modules var $45d468ca92a1d24b$export$2e2bcd8739ae039={ name: "computeStyles", enabled: true, phase:
            "beforeWrite", fn: $45d468ca92a1d24b$var$computeStyles, data: {} }; }); parcelRequire.register( "7kchx", function(module, exports) { $parcel$export(module.exports, "default", ()=> $5553ed9c2ee225e3$export$2e2bcd8739ae039); function $5553ed9c2ee225e3$export$2e2bcd8739ae039(placement) { return placement.split("-")[1]; } }); parcelRequire.register("jU5vk", function(module, exports) { $parcel$export(module.exports, "default",
            () => $e7d7845625089588$export$2e2bcd8739ae039); var $93G53 = parcelRequire("93G53"); var $e7d7845625089588$var$passive = { passive: true }; function $e7d7845625089588$var$effect(_ref) { var state = _ref.state, instance = _ref.instance, options
            = _ref.options; var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize; var window = (0, $93G53.default)(state.elements.popper);
            var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper); if (scroll) scrollParents.forEach(function(scrollParent) { scrollParent.addEventListener("scroll", instance.update, $e7d7845625089588$var$passive); });
            if (resize) window.addEventListener("resize", instance.update, $e7d7845625089588$var$passive); return function() { if (scroll) scrollParents.forEach(function(scrollParent) { scrollParent.removeEventListener("scroll", instance.update, $e7d7845625089588$var$passive);
            }); if (resize) window.removeEventListener("resize", instance.update, $e7d7845625089588$var$passive); }; } // eslint-disable-next-line import/no-unused-modules var $e7d7845625089588$export$2e2bcd8739ae039 = { name: "eventListeners", enabled:
            true, phase: "write", fn: function fn() {}, effect: $e7d7845625089588$var$effect, data: {} }; }); parcelRequire.register("hMqHB", function(module, exports) { $parcel$export(module.exports, "default", () => $cf1ba1dd94205465$export$2e2bcd8739ae039);
            var $eFT7Y = parcelRequire("eFT7Y"); var $h06jI = parcelRequire("h06jI"); var $4NVvZ = parcelRequire("4NVvZ"); var $gGcga = parcelRequire("gGcga"); var $iN4T7 = parcelRequire("iN4T7"); var $1KQnQ = parcelRequire("1KQnQ"); var $7kchx = parcelRequire("7kchx");
            function $cf1ba1dd94205465$var$getExpandedFallbackPlacements(placement) { if ((0, $h06jI.default)(placement) === (0, $1KQnQ.auto)) return []; var oppositePlacement = (0, $eFT7Y.default)(placement); return [ (0, $4NVvZ.default)(placement),
            oppositePlacement, (0, $4NVvZ.default)(oppositePlacement) ]; } function $cf1ba1dd94205465$var$flip(_ref) { var state = _ref.state, options = _ref.options, name = _ref.name; if (state.modifiersData[name]._skip) return; var _options$mainAxis
            = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements,
            padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
            allowedAutoPlacements = options.allowedAutoPlacements; var preferredPlacement = state.options.placement; var basePlacement = (0, $h06jI.default)(preferredPlacement); var isBasePlacement = basePlacement === preferredPlacement; var fallbackPlacements
            = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [ (0, $eFT7Y.default)(preferredPlacement) ] : $cf1ba1dd94205465$var$getExpandedFallbackPlacements(preferredPlacement)); var placements = [ preferredPlacement ].concat(fallbackPlacements).reduce(function(acc,
            placement) { return acc.concat((0, $h06jI.default)(placement) === (0, $1KQnQ.auto) ? (0, $iN4T7.default)(state, { placement: placement, boundary: boundary, rootBoundary: rootBoundary, padding: padding, flipVariations: flipVariations, allowedAutoPlacements:
            allowedAutoPlacements }) : placement); }, []); var referenceRect = state.rects.reference; var popperRect = state.rects.popper; var checksMap = new Map(); var makeFallbackChecks = true; var firstFittingPlacement = placements[0]; for(var i =
            0; i
            < placements.length; i++){ var placement=p lacements[i]; var _basePlacement=( 0, $h06jI.default)(placement); var isStartVariation=( 0, $7kchx.default)(placement)===( 0, $1KQnQ.start); var isVertical=[ (0, $1KQnQ.top), (0, $1KQnQ.bottom)
                ].indexOf(_basePlacement)>= 0; var len = isVertical ? "width" : "height"; var overflow = (0, $gGcga.default)(state, { placement: placement, boundary: boundary, rootBoundary: rootBoundary, altBoundary: altBoundary, padding: padding }); var mainVariationSide = isVertical
                ? isStartVariation ? (0, $1KQnQ.right) : (0, $1KQnQ.left) : isStartVariation ? (0, $1KQnQ.bottom) : (0, $1KQnQ.top); if (referenceRect[len] > popperRect[len]) mainVariationSide = (0, $eFT7Y.default)(mainVariationSide); var altVariationSide
                = (0, $eFT7Y.default)(mainVariationSide); var checks = []; if (checkMainAxis) checks.push(overflow[_basePlacement]
                <=0 ); if (checkAltAxis) checks.push(overflow[mainVariationSide] <=0 , overflow[altVariationSide] <=0 ); if (checks.every(function(check)
                    { return check; })) { firstFittingPlacement=p lacement; makeFallbackChecks=f alse; break; } checksMap.set(placement, checks); } if (makeFallbackChecks) { // `2` may be desired in some cases – research later var numberOfChecks=f lipVariations
                    ? 3 : 1; var _loop=f unction _loop(_i) { var fittingPlacement=p lacements.find(function(placement) { var checks=c hecksMap.get(placement); if (checks) return checks.slice(0, _i).every(function(check) { return check; }); }); if (fittingPlacement)
                    { firstFittingPlacement=f ittingPlacement; return "break"; } }; for(var _i=n umberOfChecks; _i> 0; _i--){ var _ret = _loop(_i); if (_ret === "break") break; } } if (state.placement !== firstFittingPlacement) { state.modifiersData[name]._skip = true; state.placement = firstFittingPlacement; state.reset = true; } } // eslint-disable-next-line
                    import/no-unused-modules var $cf1ba1dd94205465$export$2e2bcd8739ae039 = { name: "flip", enabled: true, phase: "main", fn: $cf1ba1dd94205465$var$flip, requiresIfExists: [ "offset" ], data: { _skip: false } }; }); parcelRequire.register("eFT7Y",
                    function(module, exports) { $parcel$export(module.exports, "default", () => $aaefa8315f14c8e2$export$2e2bcd8739ae039); var $aaefa8315f14c8e2$var$hash = { left: "right", right: "left", bottom: "top", top: "bottom" }; function $aaefa8315f14c8e2$export$2e2bcd8739ae039(placement)
                    { return placement.replace(/left|right|bottom|top/g, function(matched) { return $aaefa8315f14c8e2$var$hash[matched]; }); } }); parcelRequire.register("4NVvZ", function(module, exports) { $parcel$export(module.exports, "default", ()
                    => $37f85a49ff946cb6$export$2e2bcd8739ae039); var $37f85a49ff946cb6$var$hash = { start: "end", end: "start" }; function $37f85a49ff946cb6$export$2e2bcd8739ae039(placement) { return placement.replace(/start|end/g, function(matched)
                    { return $37f85a49ff946cb6$var$hash[matched]; }); } }); parcelRequire.register("gGcga", function(module, exports) { $parcel$export(module.exports, "default", () => $c24a1421ba2f823c$export$2e2bcd8739ae039); var $5T76m = parcelRequire("5T76m");
                    var $17OuU = parcelRequire("17OuU"); var $41Z5W = parcelRequire("41Z5W"); var $dgDBP = parcelRequire("dgDBP"); var $ik7Fq = parcelRequire("ik7Fq"); var $1KQnQ = parcelRequire("1KQnQ"); var $93iQ7 = parcelRequire("93iQ7"); var $3Os63
                    = parcelRequire("3Os63"); var $hdgde = parcelRequire("hdgde"); function $c24a1421ba2f823c$export$2e2bcd8739ae039(state, options) { if (options === void 0) options = {}; var _options = options, _options$placement = _options.placement,
                    placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary,
                    boundary = _options$boundary === void 0 ? (0, $1KQnQ.clippingParents) : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? (0, $1KQnQ.viewport) : _options$rootBoundary,
                    _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? (0, $1KQnQ.popper) : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void
                    0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding; var paddingObject = (0, $3Os63.default)(typeof padding !== "number" ? padding : (0, $hdgde.default)(padding,
                    (0, $1KQnQ.basePlacements))); var altContext = elementContext === (0, $1KQnQ.popper) ? (0, $1KQnQ.reference) : (0, $1KQnQ.popper); var popperRect = state.rects.popper; var element = state.elements[altBoundary ? altContext : elementContext];
                    var clippingClientRect = (0, $5T76m.default)((0, $93iQ7.isElement)(element) ? element : element.contextElement || (0, $17OuU.default)(state.elements.popper), boundary, rootBoundary, strategy); var referenceClientRect = (0, $41Z5W.default)(state.elements.reference);
                    var popperOffsets = (0, $dgDBP.default)({ reference: referenceClientRect, element: popperRect, strategy: "absolute", placement: placement }); var popperClientRect = (0, $ik7Fq.default)(Object.assign({}, popperRect, popperOffsets));
                    var elementClientRect = elementContext === (0, $1KQnQ.popper) ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect // 0 or negative = within the clipping rect var overflowOffsets = { top: clippingClientRect.top
                    - elementClientRect.top + paddingObject.top, bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom, left: clippingClientRect.left - elementClientRect.left + paddingObject.left, right: elementClientRect.right
                    - clippingClientRect.right + paddingObject.right }; var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element if (elementContext === (0, $1KQnQ.popper) && offsetData) { var offset = offsetData[placement];
                    Object.keys(overflowOffsets).forEach(function(key) { var multiply = [ (0, $1KQnQ.right), (0, $1KQnQ.bottom) ].indexOf(key) >= 0 ? 1 : -1; var axis = [ (0, $1KQnQ.top), (0, $1KQnQ.bottom) ].indexOf(key) >= 0 ? "y" : "x"; overflowOffsets[key]
                    += offset[axis] * multiply; }); } return overflowOffsets; } }); parcelRequire.register("5T76m", function(module, exports) { $parcel$export(module.exports, "default", () => $449799046a13d100$export$2e2bcd8739ae039); var $1KQnQ = parcelRequire("1KQnQ");
                    var $e1yxe = parcelRequire("e1yxe"); var $ef4Kl = parcelRequire("ef4Kl"); var $cqjGx = parcelRequire("cqjGx"); var $5KzeH = parcelRequire("5KzeH"); var $17OuU = parcelRequire("17OuU"); var $huVQQ = parcelRequire("huVQQ"); var $93iQ7
                    = parcelRequire("93iQ7"); var $41Z5W = parcelRequire("41Z5W"); var $aerap = parcelRequire("aerap"); var $ciq1x = parcelRequire("ciq1x"); var $oKPBf = parcelRequire("oKPBf"); var $ik7Fq = parcelRequire("ik7Fq"); var $4J8n1 = parcelRequire("4J8n1");
                    function $449799046a13d100$var$getInnerBoundingClientRect(element, strategy) { var rect = (0, $41Z5W.default)(element, false, strategy === "fixed"); rect.top = rect.top + element.clientTop; rect.left = rect.left + element.clientLeft;
                    rect.bottom = rect.top + element.clientHeight; rect.right = rect.left + element.clientWidth; rect.width = element.clientWidth; rect.height = element.clientHeight; rect.x = rect.left; rect.y = rect.top; return rect; } function $449799046a13d100$var$getClientRectFromMixedType(element,
                    clippingParent, strategy) { return clippingParent === (0, $1KQnQ.viewport) ? (0, $ik7Fq.default)((0, $e1yxe.default)(element, strategy)) : (0, $93iQ7.isElement)(clippingParent) ? $449799046a13d100$var$getInnerBoundingClientRect(clippingParent,
                    strategy) : (0, $ik7Fq.default)((0, $ef4Kl.default)((0, $17OuU.default)(element))); } // A "clipping parent" is an overflowable container with the characteristic of // clipping (or hiding) overflowing elements with a position different
                    from // `initial` function $449799046a13d100$var$getClippingParents(element) { var clippingParents = (0, $cqjGx.default)((0, $aerap.default)(element)); var canEscapeClipping = [ "absolute", "fixed" ].indexOf((0, $huVQQ.default)(element).position)
                    >= 0; var clipperElement = canEscapeClipping && (0, $93iQ7.isHTMLElement)(element) ? (0, $5KzeH.default)(element) : element; if (!(0, $93iQ7.isElement)(clipperElement)) return []; // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
                    return clippingParents.filter(function(clippingParent) { return (0, $93iQ7.isElement)(clippingParent) && (0, $ciq1x.default)(clippingParent, clipperElement) && (0, $oKPBf.default)(clippingParent) !== "body"; }); } // Gets the maximum
                    area that the element is visible in due to any number of function $449799046a13d100$export$2e2bcd8739ae039(element, boundary, rootBoundary, strategy) { var mainClippingParents = boundary === "clippingParents" ? $449799046a13d100$var$getClippingParents(element)
                    : [].concat(boundary); var clippingParents = [].concat(mainClippingParents, [ rootBoundary ]); var firstClippingParent = clippingParents[0]; var clippingRect = clippingParents.reduce(function(accRect, clippingParent) { var rect = $449799046a13d100$var$getClientRectFromMixedType(element,
                    clippingParent, strategy); accRect.top = (0, $4J8n1.max)(rect.top, accRect.top); accRect.right = (0, $4J8n1.min)(rect.right, accRect.right); accRect.bottom = (0, $4J8n1.min)(rect.bottom, accRect.bottom); accRect.left = (0, $4J8n1.max)(rect.left,
                    accRect.left); return accRect; }, $449799046a13d100$var$getClientRectFromMixedType(element, firstClippingParent, strategy)); clippingRect.width = clippingRect.right - clippingRect.left; clippingRect.height = clippingRect.bottom - clippingRect.top;
                    clippingRect.x = clippingRect.left; clippingRect.y = clippingRect.top; return clippingRect; } }); parcelRequire.register("e1yxe", function(module, exports) { $parcel$export(module.exports, "default", () => $a35bf29d5fc5ab40$export$2e2bcd8739ae039);
                    var $93G53 = parcelRequire("93G53"); var $17OuU = parcelRequire("17OuU"); var $8fnXo = parcelRequire("8fnXo"); var $gotNd = parcelRequire("gotNd"); function $a35bf29d5fc5ab40$export$2e2bcd8739ae039(element, strategy) { var win = (0,
                    $93G53.default)(element); var html = (0, $17OuU.default)(element); var visualViewport = win.visualViewport; var width = html.clientWidth; var height = html.clientHeight; var x = 0; var y = 0; if (visualViewport) { width = visualViewport.width;
                    height = visualViewport.height; var layoutViewport = (0, $gotNd.default)(); if (layoutViewport || !layoutViewport && strategy === "fixed") { x = visualViewport.offsetLeft; y = visualViewport.offsetTop; } } return { width: width, height:
                    height, x: x + (0, $8fnXo.default)(element), y: y }; } }); parcelRequire.register("8fnXo", function(module, exports) { $parcel$export(module.exports, "default", () => $60124eceeef28a28$export$2e2bcd8739ae039); var $41Z5W = parcelRequire("41Z5W");
                    var $17OuU = parcelRequire("17OuU"); var $4WW7r = parcelRequire("4WW7r"); function $60124eceeef28a28$export$2e2bcd8739ae039(element) { // If
                    <html> has a CSS width greater than the viewport, then this will be // incorrect for RTL. // Popper 1 is broken in this case and never had a bug report so let's assume // it's not an issue. I don't think anyone ever specifies width on
                    <html>
                    // anyway. // Browsers where the left scrollbar doesn't cause an issue report `0` for // this (e.g. Edge 2019, IE11, Safari) return (0, $41Z5W.default)((0, $17OuU.default)(element)).left + (0, $4WW7r.default)(element).scrollLeft; } }); parcelRequire.register("4WW7r",
                    function(module, exports) { $parcel$export(module.exports, "default", () => $39a9a96b6f99add9$export$2e2bcd8739ae039); var $93G53 = parcelRequire("93G53"); function $39a9a96b6f99add9$export$2e2bcd8739ae039(node) { var win = (0, $93G53.default)(node);
                    var scrollLeft = win.pageXOffset; var scrollTop = win.pageYOffset; return { scrollLeft: scrollLeft, scrollTop: scrollTop }; } }); parcelRequire.register("ef4Kl", function(module, exports) { $parcel$export(module.exports, "default",
                    () => $a5e625ef2dd801ec$export$2e2bcd8739ae039); var $17OuU = parcelRequire("17OuU"); var $huVQQ = parcelRequire("huVQQ"); var $8fnXo = parcelRequire("8fnXo"); var $4WW7r = parcelRequire("4WW7r"); var $4J8n1 = parcelRequire("4J8n1");
                    function $a5e625ef2dd801ec$export$2e2bcd8739ae039(element) { var _element$ownerDocumen; var html = (0, $17OuU.default)(element); var winScroll = (0, $4WW7r.default)(element); var body = (_element$ownerDocumen = element.ownerDocument)
                    == null ? void 0 : _element$ownerDocumen.body; var width = (0, $4J8n1.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0); var height = (0, $4J8n1.max)(html.scrollHeight, html.clientHeight,
                    body ? body.scrollHeight : 0, body ? body.clientHeight : 0); var x = -winScroll.scrollLeft + (0, $8fnXo.default)(element); var y = -winScroll.scrollTop; if ((0, $huVQQ.default)(body || html).direction === "rtl") x += (0, $4J8n1.max)(html.clientWidth,
                    body ? body.clientWidth : 0) - width; return { width: width, height: height, x: x, y: y }; } }); parcelRequire.register("cqjGx", function(module, exports) { $parcel$export(module.exports, "default", () => $90b72ed15edfd54a$export$2e2bcd8739ae039);
                    var $3QP5e = parcelRequire("3QP5e"); var $aerap = parcelRequire("aerap"); var $93G53 = parcelRequire("93G53"); var $1ADUj = parcelRequire("1ADUj"); function $90b72ed15edfd54a$export$2e2bcd8739ae039(element, list) { var _element$ownerDocumen;
                    if (list === void 0) list = []; var scrollParent = (0, $3QP5e.default)(element); var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body); var win = (0, $93G53.default)(scrollParent);
                    var target = isBody ? [ win ].concat(win.visualViewport || [], (0, $1ADUj.default)(scrollParent) ? scrollParent : []) : scrollParent; var updatedList = list.concat(target); return isBody ? updatedList : updatedList.concat($90b72ed15edfd54a$export$2e2bcd8739ae039((0,
                    $aerap.default)(target))); } }); parcelRequire.register("3QP5e", function(module, exports) { $parcel$export(module.exports, "default", () => $2cddda83e3357241$export$2e2bcd8739ae039); var $aerap = parcelRequire("aerap"); var $1ADUj
                    = parcelRequire("1ADUj"); var $oKPBf = parcelRequire("oKPBf"); var $93iQ7 = parcelRequire("93iQ7"); function $2cddda83e3357241$export$2e2bcd8739ae039(node) { if ([ "html", "body", "#document" ].indexOf((0, $oKPBf.default)(node)) >=
                    0) // $FlowFixMe[incompatible-return]: assume body is always available return node.ownerDocument.body; if ((0, $93iQ7.isHTMLElement)(node) && (0, $1ADUj.default)(node)) return node; return $2cddda83e3357241$export$2e2bcd8739ae039((0,
                    $aerap.default)(node)); } }); parcelRequire.register("1ADUj", function(module, exports) { $parcel$export(module.exports, "default", () => $12881c0013479a14$export$2e2bcd8739ae039); var $huVQQ = parcelRequire("huVQQ"); function $12881c0013479a14$export$2e2bcd8739ae039(element)
                    { // Firefox wants us to check `-x` and `-y` variations as well var _getComputedStyle = (0, $huVQQ.default)(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
                    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX); } }); parcelRequire.register("ik7Fq", function(module, exports) { $parcel$export(module.exports, "default", () => $d5700acdd3ba9a3c$export$2e2bcd8739ae039);
                    function $d5700acdd3ba9a3c$export$2e2bcd8739ae039(rect) { return Object.assign({}, rect, { left: rect.x, top: rect.y, right: rect.x + rect.width, bottom: rect.y + rect.height }); } }); parcelRequire.register("dgDBP", function(module,
                    exports) { $parcel$export(module.exports, "default", () => $9a8b7e877fbba4f3$export$2e2bcd8739ae039); var $h06jI = parcelRequire("h06jI"); var $7kchx = parcelRequire("7kchx"); var $g1hRA = parcelRequire("g1hRA"); var $1KQnQ = parcelRequire("1KQnQ");
                    function $9a8b7e877fbba4f3$export$2e2bcd8739ae039(_ref) { var reference = _ref.reference, element = _ref.element, placement = _ref.placement; var basePlacement = placement ? (0, $h06jI.default)(placement) : null; var variation = placement
                    ? (0, $7kchx.default)(placement) : null; var commonX = reference.x + reference.width / 2 - element.width / 2; var commonY = reference.y + reference.height / 2 - element.height / 2; var offsets; switch(basePlacement){ case 0, $1KQnQ.top:
                    offsets = { x: commonX, y: reference.y - element.height }; break; case 0, $1KQnQ.bottom: offsets = { x: commonX, y: reference.y + reference.height }; break; case 0, $1KQnQ.right: offsets = { x: reference.x + reference.width, y: commonY
                    }; break; case 0, $1KQnQ.left: offsets = { x: reference.x - element.width, y: commonY }; break; default: offsets = { x: reference.x, y: reference.y }; } var mainAxis = basePlacement ? (0, $g1hRA.default)(basePlacement) : null; if (mainAxis
                    != null) { var len = mainAxis === "y" ? "height" : "width"; switch(variation){ case 0, $1KQnQ.start: offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2); break; case 0, $1KQnQ.end: offsets[mainAxis] = offsets[mainAxis]
                    + (reference[len] / 2 - element[len] / 2); break; default: } } return offsets; } }); parcelRequire.register("iN4T7", function(module, exports) { $parcel$export(module.exports, "default", () => $dae0983d65fbfc0b$export$2e2bcd8739ae039);
                    var $7kchx = parcelRequire("7kchx"); var $1KQnQ = parcelRequire("1KQnQ"); var $gGcga = parcelRequire("gGcga"); var $h06jI = parcelRequire("h06jI"); function $dae0983d65fbfc0b$export$2e2bcd8739ae039(state, options) { if (options ===
                    void 0) options = {}; var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP
                    = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? (0, $1KQnQ.placements) : _options$allowedAutoP; var variation = (0, $7kchx.default)(placement); var placements = variation ? flipVariations
                    ? (0, $1KQnQ.variationPlacements) : (0, $1KQnQ.variationPlacements).filter(function(placement) { return (0, $7kchx.default)(placement) === variation; }) : (0, $1KQnQ.basePlacements); var allowedPlacements = placements.filter(function(placement)
                    { return allowedAutoPlacements.indexOf(placement) >= 0; }); if (allowedPlacements.length === 0) allowedPlacements = placements; // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions... var overflows =
                    allowedPlacements.reduce(function(acc, placement) { acc[placement] = (0, $gGcga.default)(state, { placement: placement, boundary: boundary, rootBoundary: rootBoundary, padding: padding })[(0, $h06jI.default)(placement)]; return acc;
                    }, {}); return Object.keys(overflows).sort(function(a, b) { return overflows[a] - overflows[b]; }); } }); parcelRequire.register("95q7y", function(module, exports) { $parcel$export(module.exports, "default", () => $69d8d7bda7717b01$export$2e2bcd8739ae039);
                    var $1KQnQ = parcelRequire("1KQnQ"); var $gGcga = parcelRequire("gGcga"); function $69d8d7bda7717b01$var$getSideOffsets(overflow, rect, preventedOffsets) { if (preventedOffsets === void 0) preventedOffsets = { x: 0, y: 0 }; return
                    { top: overflow.top - rect.height - preventedOffsets.y, right: overflow.right - rect.width + preventedOffsets.x, bottom: overflow.bottom - rect.height + preventedOffsets.y, left: overflow.left - rect.width - preventedOffsets.x }; }
                    function $69d8d7bda7717b01$var$isAnySideFullyClipped(overflow) { return [ (0, $1KQnQ.top), (0, $1KQnQ.right), (0, $1KQnQ.bottom), (0, $1KQnQ.left) ].some(function(side) { return overflow[side] >= 0; }); } function $69d8d7bda7717b01$var$hide(_ref)
                    { var state = _ref.state, name = _ref.name; var referenceRect = state.rects.reference; var popperRect = state.rects.popper; var preventedOffsets = state.modifiersData.preventOverflow; var referenceOverflow = (0, $gGcga.default)(state,
                    { elementContext: "reference" }); var popperAltOverflow = (0, $gGcga.default)(state, { altBoundary: true }); var referenceClippingOffsets = $69d8d7bda7717b01$var$getSideOffsets(referenceOverflow, referenceRect); var popperEscapeOffsets
                    = $69d8d7bda7717b01$var$getSideOffsets(popperAltOverflow, popperRect, preventedOffsets); var isReferenceHidden = $69d8d7bda7717b01$var$isAnySideFullyClipped(referenceClippingOffsets); var hasPopperEscaped = $69d8d7bda7717b01$var$isAnySideFullyClipped(popperEscapeOffsets);
                    state.modifiersData[name] = { referenceClippingOffsets: referenceClippingOffsets, popperEscapeOffsets: popperEscapeOffsets, isReferenceHidden: isReferenceHidden, hasPopperEscaped: hasPopperEscaped }; state.attributes.popper = Object.assign({},
                    state.attributes.popper, { "data-popper-reference-hidden": isReferenceHidden, "data-popper-escaped": hasPopperEscaped }); } // eslint-disable-next-line import/no-unused-modules var $69d8d7bda7717b01$export$2e2bcd8739ae039 = { name:
                    "hide", enabled: true, phase: "main", requiresIfExists: [ "preventOverflow" ], fn: $69d8d7bda7717b01$var$hide }; }); parcelRequire.register("lWzyf", function(module, exports) { $parcel$export(module.exports, "default", () => $ff9a9783c10adebd$export$2e2bcd8739ae039);
                    var $h06jI = parcelRequire("h06jI"); var $1KQnQ = parcelRequire("1KQnQ"); function $ff9a9783c10adebd$export$7fa02d8595b015ed(placement, rects, offset) { var basePlacement = (0, $h06jI.default)(placement); var invertDistance = [ (0,
                    $1KQnQ.left), (0, $1KQnQ.top) ].indexOf(basePlacement) >= 0 ? -1 : 1; var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, { placement: placement })) : offset, skidding = _ref[0], distance = _ref[1]; skidding =
                    skidding || 0; distance = (distance || 0) * invertDistance; return [ (0, $1KQnQ.left), (0, $1KQnQ.right) ].indexOf(basePlacement) >= 0 ? { x: distance, y: skidding } : { x: skidding, y: distance }; } function $ff9a9783c10adebd$var$offset(_ref2)
                    { var state = _ref2.state, options = _ref2.options, name = _ref2.name; var _options$offset = options.offset, offset = _options$offset === void 0 ? [ 0, 0 ] : _options$offset; var data = (0, $1KQnQ.placements).reduce(function(acc, placement)
                    { acc[placement] = $ff9a9783c10adebd$export$7fa02d8595b015ed(placement, state.rects, offset); return acc; }, {}); var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y; if (state.modifiersData.popperOffsets
                    != null) { state.modifiersData.popperOffsets.x += x; state.modifiersData.popperOffsets.y += y; } state.modifiersData[name] = data; } // eslint-disable-next-line import/no-unused-modules var $ff9a9783c10adebd$export$2e2bcd8739ae039
                    = { name: "offset", enabled: true, phase: "main", requires: [ "popperOffsets" ], fn: $ff9a9783c10adebd$var$offset }; }); parcelRequire.register("cePA2", function(module, exports) { $parcel$export(module.exports, "default", () => $8e8ecd9a827a16d7$export$2e2bcd8739ae039);
                    var $dgDBP = parcelRequire("dgDBP"); function $8e8ecd9a827a16d7$var$popperOffsets(_ref) { var state = _ref.state, name = _ref.name; // Offsets are the actual position the popper needs to have to be // properly positioned near its reference
                    element // This is the most basic placement, and will be adjusted by // the modifiers in the next step state.modifiersData[name] = (0, $dgDBP.default)({ reference: state.rects.reference, element: state.rects.popper, strategy: "absolute",
                    placement: state.placement }); } // eslint-disable-next-line import/no-unused-modules var $8e8ecd9a827a16d7$export$2e2bcd8739ae039 = { name: "popperOffsets", enabled: true, phase: "read", fn: $8e8ecd9a827a16d7$var$popperOffsets, data:
                    {} }; }); parcelRequire.register("bxdrS", function(module, exports) { $parcel$export(module.exports, "default", () => $865d356b2ca960a5$export$2e2bcd8739ae039); var $1KQnQ = parcelRequire("1KQnQ"); var $h06jI = parcelRequire("h06jI");
                    var $g1hRA = parcelRequire("g1hRA"); var $8ptl2 = parcelRequire("8ptl2"); var $cOvrb = parcelRequire("cOvrb"); var $dElKO = parcelRequire("dElKO"); var $5KzeH = parcelRequire("5KzeH"); var $gGcga = parcelRequire("gGcga"); var $7kchx
                    = parcelRequire("7kchx"); var $gcu3h = parcelRequire("gcu3h"); var $4J8n1 = parcelRequire("4J8n1"); function $865d356b2ca960a5$var$preventOverflow(_ref) { var state = _ref.state, options = _ref.options, name = _ref.name; var _options$mainAxis
                    = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary
                    = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset
                    = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset; var overflow = (0, $gGcga.default)(state, { boundary: boundary, rootBoundary: rootBoundary, padding: padding, altBoundary: altBoundary }); var basePlacement = (0, $h06jI.default)(state.placement);
                    var variation = (0, $7kchx.default)(state.placement); var isBasePlacement = !variation; var mainAxis = (0, $g1hRA.default)(basePlacement); var altAxis = (0, $8ptl2.default)(mainAxis); var popperOffsets = state.modifiersData.popperOffsets;
                    var referenceRect = state.rects.reference; var popperRect = state.rects.popper; var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, { placement: state.placement })) : tetherOffset;
                    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? { mainAxis: tetherOffsetValue, altAxis: tetherOffsetValue } : Object.assign({ mainAxis: 0, altAxis: 0 }, tetherOffsetValue); var offsetModifierState = state.modifiersData.offset
                    ? state.modifiersData.offset[state.placement] : null; var data = { x: 0, y: 0 }; if (!popperOffsets) return; if (checkMainAxis) { var _offsetModifierState$; var mainSide = mainAxis === "y" ? (0, $1KQnQ.top) : (0, $1KQnQ.left); var
                    altSide = mainAxis === "y" ? (0, $1KQnQ.bottom) : (0, $1KQnQ.right); var len = mainAxis === "y" ? "height" : "width"; var offset = popperOffsets[mainAxis]; var min = offset + overflow[mainSide]; var max = offset - overflow[altSide];
                    var additive = tether ? -popperRect[len] / 2 : 0; var minLen = variation === (0, $1KQnQ.start) ? referenceRect[len] : popperRect[len]; var maxLen = variation === (0, $1KQnQ.start) ? -popperRect[len] : -referenceRect[len]; // We need
                    to include the arrow in the calculation so the arrow doesn't go // outside the reference bounds var arrowElement = state.elements.arrow; var arrowRect = tether && arrowElement ? (0, $dElKO.default)(arrowElement) : { width: 0, height:
                    0 }; var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : (0, $gcu3h.default)(); var arrowPaddingMin = arrowPaddingObject[mainSide]; var arrowPaddingMax = arrowPaddingObject[altSide];
                    // If the reference length is smaller than the arrow length, we don't want // to include its full size in the calculation. If the reference is small // and near the edge of a boundary, the popper can overflow even if the // reference
                    is not overflowing as well (e.g. virtual elements with no // width or height) var arrowLen = (0, $cOvrb.within)(0, referenceRect[len], arrowRect[len]); var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen
                    - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis; var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax
                    + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis; var arrowOffsetParent = state.elements.arrow && (0, $5KzeH.default)(state.elements.arrow); var clientOffset = arrowOffsetParent
                    ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0; var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$
                    : 0; var tetherMin = offset + minOffset - offsetModifierValue - clientOffset; var tetherMax = offset + maxOffset - offsetModifierValue; var preventedOffset = (0, $cOvrb.within)(tether ? (0, $4J8n1.min)(min, tetherMin) : min, offset,
                    tether ? (0, $4J8n1.max)(max, tetherMax) : max); popperOffsets[mainAxis] = preventedOffset; data[mainAxis] = preventedOffset - offset; } if (checkAltAxis) { var _offsetModifierState$2; var _mainSide = mainAxis === "x" ? (0, $1KQnQ.top)
                    : (0, $1KQnQ.left); var _altSide = mainAxis === "x" ? (0, $1KQnQ.bottom) : (0, $1KQnQ.right); var _offset = popperOffsets[altAxis]; var _len = altAxis === "y" ? "height" : "width"; var _min = _offset + overflow[_mainSide]; var _max
                    = _offset - overflow[_altSide]; var isOriginSide = [ (0, $1KQnQ.top), (0, $1KQnQ.left) ].indexOf(basePlacement) !== -1; var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis])
                    != null ? _offsetModifierState$2 : 0; var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis; var _tetherMax = isOriginSide ? _offset + referenceRect[_len]
                    + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max; var _preventedOffset = tether && isOriginSide ? (0, $cOvrb.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, $cOvrb.within)(tether ? _tetherMin
                    : _min, _offset, tether ? _tetherMax : _max); popperOffsets[altAxis] = _preventedOffset; data[altAxis] = _preventedOffset - _offset; } state.modifiersData[name] = data; } // eslint-disable-next-line import/no-unused-modules var $865d356b2ca960a5$export$2e2bcd8739ae039
                    = { name: "preventOverflow", enabled: true, phase: "main", fn: $865d356b2ca960a5$var$preventOverflow, requiresIfExists: [ "offset" ] }; }); parcelRequire.register("8ptl2", function(module, exports) { $parcel$export(module.exports,
                    "default", () => $61f76a8076c296c7$export$2e2bcd8739ae039); function $61f76a8076c296c7$export$2e2bcd8739ae039(axis) { return axis === "x" ? "y" : "x"; } }); parcelRequire.register("8iXfp", function(module, exports) { $parcel$export(module.exports,
                    "popperGenerator", () => $60bdf67e43f5dfcb$export$ed5e13716264f202); $parcel$export(module.exports, "createPopper", () => $60bdf67e43f5dfcb$export$8f7491d57c8f97a9); var $gcqB4 = parcelRequire("gcqB4"); var $dElKO = parcelRequire("dElKO");
                    var $cqjGx = parcelRequire("cqjGx"); var $5KzeH = parcelRequire("5KzeH"); var $ahlk8 = parcelRequire("ahlk8"); var $dlelj = parcelRequire("dlelj"); var $l57aq = parcelRequire("l57aq"); var $gGcga = parcelRequire("gGcga"); var $93iQ7
                    = parcelRequire("93iQ7"); var $60bdf67e43f5dfcb$var$DEFAULT_OPTIONS = { placement: "bottom", modifiers: [], strategy: "absolute" }; function $60bdf67e43f5dfcb$var$areValidElements() { for(var _len = arguments.length, args = new Array(_len),
                    _key = 0; _key
                    < _len; _key++)args[_key]=a rguments[_key]; return !args.some(function(element) { return !(element && typeof element.getBoundingClientRect==="function" ); }); } function $60bdf67e43f5dfcb$export$ed5e13716264f202(generatorOptions)
                        { if (generatorOptions===v oid 0) generatorOptions={ }; var _generatorOptions=g eneratorOptions, _generatorOptions$def=_ generatorOptions.defaultModifiers, defaultModifiers=_ generatorOptions$def===v oid 0 ? [] : _generatorOptions$def,
                        _generatorOptions$def2=_ generatorOptions.defaultOptions, defaultOptions=_ generatorOptions$def2===v oid 0 ? $60bdf67e43f5dfcb$var$DEFAULT_OPTIONS : _generatorOptions$def2; return function createPopper(reference, popper, options) {
                        if (options===v oid 0) options=d efaultOptions; var state={ placement: "bottom", orderedModifiers: [], options: Object.assign({}, $60bdf67e43f5dfcb$var$DEFAULT_OPTIONS, defaultOptions), modifiersData: {}, elements: { reference: reference,
                        popper: popper }, attributes: {}, styles: {} }; var effectCleanupFns=[ ]; var isDestroyed=f alse; var instance={ state: state, setOptions: function setOptions(setOptionsAction) { var options=t ypeof setOptionsAction==="function" ?
                        setOptionsAction(state.options) : setOptionsAction; cleanupModifierEffects(); state.options=O bject.assign({}, defaultOptions, state.options, options); state.scrollParents={ reference: (0, $93iQ7.isElement)(reference) ? (0, $cqjGx.default)(reference)
                        : reference.contextElement ? (0, $cqjGx.default)(reference.contextElement) : [], popper: (0, $cqjGx.default)(popper) }; // Orders the modifiers based on their dependencies and `phase` // properties var orderedModifiers=( 0, $ahlk8.default)((0,
                        $l57aq.default)([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers state.orderedModifiers=o rderedModifiers.filter(function(m) { return m.enabled; }); runModifierEffects(); return instance.update();
                        }, // Sync update – it will always be executed, even if not necessary. This // is useful for low frequency updates where sync behavior simplifies the // logic. // For high frequency updates (e.g. `resize` and `scroll` events), always
                    // prefer the async Popper#update method forceUpdate: function forceUpdate() { if (isDestroyed) return; var _state$elements=s tate.elements, reference=_ state$elements.reference, popper=_ state$elements.popper; // Don 't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!$60bdf67e43f5dfcb$var$areValidElements(reference, popper)) return;
                 // Store the reference and popper rects to be read by modifiers
                state.rects = {
                    reference: (0, $gcqB4.default)(reference, (0, $5KzeH.default)(popper), state.options.strategy === "fixed"),
                    popper: (0, $dElKO.default)(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state.reset = false;
                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update. // To ensure persistent data, use `${name}#persistent` state.orderedModifiers.forEach(function(modifier) { return state.modifiersData[modifier.name]=O bject.assign({}, modifier.data);
                        }); for(var index=0 ; index < state.orderedModifiers.length; index++){ if (state.reset===t rue) { state.reset=f alse; index=- 1; continue; } var _state$orderedModifie=s tate.orderedModifiers[index], fn=_ state$orderedModifie.fn, _state$orderedModifie2=_
                        state$orderedModifie.options, _options=_ state$orderedModifie2===v oid 0 ? {} : _state$orderedModifie2, name=_ state$orderedModifie.name; if (typeof fn==="function" ) state=f n({ state: state, options: _options, name: name, instance:
                        instance }) || state; } }, // Async and optimistically optimized update – it will not be executed if // not necessary (debounced to run at most once-per-tick) update: (0, $dlelj.default)(function() { return new Promise(function(resolve)
                        { instance.forceUpdate(); resolve(state); }); }), destroy: function destroy() { cleanupModifierEffects(); isDestroyed=t rue; } }; if (!$60bdf67e43f5dfcb$var$areValidElements(reference, popper)) return instance; instance.setOptions(options).then(function(state)
                        { if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state); }); // Modifiers have the ability to execute arbitrary code before the first // update cycle runs. They will be executed in the same order as the update //
                        cycle. This is useful when a modifier adds some persistent data that // other modifiers need to use, but the modifier is run after the dependent // one. function runModifierEffects() { state.orderedModifiers.forEach(function(_ref)
                        { var name=_ ref.name, _ref$options=_ ref.options, options=_ ref$options===v oid 0 ? {} : _ref$options, effect=_ ref.effect; if (typeof effect==="function" ) { var cleanupFn=e ffect({ state: state, name: name, instance: instance, options:
                        options }); var noopFn=f unction noopFn() {}; effectCleanupFns.push(cleanupFn || noopFn); } }); } function cleanupModifierEffects() { effectCleanupFns.forEach(function(fn) { return fn(); }); effectCleanupFns=[ ]; } return instance;
                        }; } var $60bdf67e43f5dfcb$export$8f7491d57c8f97a9=/ *#__PURE__*/ $60bdf67e43f5dfcb$export$ed5e13716264f202(); // eslint-disable-next-line import/no-unused-modules }); parcelRequire.register( "gcqB4", function(module, exports) { $parcel$export(module.exports,
                        "default", ()=> $bcb265ed9201975a$export$2e2bcd8739ae039); var $41Z5W = parcelRequire("41Z5W"); var $eOasn = parcelRequire("eOasn"); var $oKPBf = parcelRequire("oKPBf"); var $93iQ7 = parcelRequire("93iQ7"); var $8fnXo = parcelRequire("8fnXo"); var
                        $17OuU = parcelRequire("17OuU"); var $1ADUj = parcelRequire("1ADUj"); var $4J8n1 = parcelRequire("4J8n1"); function $bcb265ed9201975a$var$isElementScaled(element) { var rect = element.getBoundingClientRect(); var scaleX = (0, $4J8n1.round)(rect.width)
                        / element.offsetWidth || 1; var scaleY = (0, $4J8n1.round)(rect.height) / element.offsetHeight || 1; return scaleX !== 1 || scaleY !== 1; } // Returns the composite rect of an element relative to its offsetParent. function $bcb265ed9201975a$export$2e2bcd8739ae039(elementOrVirtualElement,
                        offsetParent, isFixed) { if (isFixed === void 0) isFixed = false; var isOffsetParentAnElement = (0, $93iQ7.isHTMLElement)(offsetParent); var offsetParentIsScaled = (0, $93iQ7.isHTMLElement)(offsetParent) && $bcb265ed9201975a$var$isElementScaled(offsetParent);
                        var documentElement = (0, $17OuU.default)(offsetParent); var rect = (0, $41Z5W.default)(elementOrVirtualElement, offsetParentIsScaled, isFixed); var scroll = { scrollLeft: 0, scrollTop: 0 }; var offsets = { x: 0, y: 0 }; if (isOffsetParentAnElement
                        || !isOffsetParentAnElement && !isFixed) { if ((0, $oKPBf.default)(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078 (0, $1ADUj.default)(documentElement)) scroll = (0, $eOasn.default)(offsetParent);
                        if ((0, $93iQ7.isHTMLElement)(offsetParent)) { offsets = (0, $41Z5W.default)(offsetParent, true); offsets.x += offsetParent.clientLeft; offsets.y += offsetParent.clientTop; } else if (documentElement) offsets.x = (0, $8fnXo.default)(documentElement);
                        } return { x: rect.left + scroll.scrollLeft - offsets.x, y: rect.top + scroll.scrollTop - offsets.y, width: rect.width, height: rect.height }; } }); parcelRequire.register("eOasn", function(module, exports) { $parcel$export(module.exports,
                        "default", () => $ac7dd8aeabb81fe8$export$2e2bcd8739ae039); var $4WW7r = parcelRequire("4WW7r"); var $93G53 = parcelRequire("93G53"); var $93iQ7 = parcelRequire("93iQ7"); var $ieX38 = parcelRequire("ieX38"); function $ac7dd8aeabb81fe8$export$2e2bcd8739ae039(node)
                        { if (node === (0, $93G53.default)(node) || !(0, $93iQ7.isHTMLElement)(node)) return (0, $4WW7r.default)(node); else return (0, $ieX38.default)(node); } }); parcelRequire.register("ieX38", function(module, exports) { $parcel$export(module.exports,
                        "default", () => $d47756cb7a847081$export$2e2bcd8739ae039); function $d47756cb7a847081$export$2e2bcd8739ae039(element) { return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop }; } }); parcelRequire.register("ahlk8",
                        function(module, exports) { $parcel$export(module.exports, "default", () => $77bc085de34276f2$export$2e2bcd8739ae039); var $1KQnQ = parcelRequire("1KQnQ"); function $77bc085de34276f2$var$order(modifiers) { var map = new Map();
                        var visited = new Set(); var result = []; modifiers.forEach(function(modifier) { map.set(modifier.name, modifier); }); // On visiting object, check for its dependencies and visit them recursively function sort(modifier) { visited.add(modifier.name);
                        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []); requires.forEach(function(dep) { if (!visited.has(dep)) { var depModifier = map.get(dep); if (depModifier) sort(depModifier); } }); result.push(modifier);
                        } modifiers.forEach(function(modifier) { if (!visited.has(modifier.name)) // check for visited object sort(modifier); }); return result; } function $77bc085de34276f2$export$2e2bcd8739ae039(modifiers) { // order based on dependencies
                        var orderedModifiers = $77bc085de34276f2$var$order(modifiers); // order based on phase return (0, $1KQnQ.modifierPhases).reduce(function(acc, phase) { return acc.concat(orderedModifiers.filter(function(modifier) { return modifier.phase
                        === phase; })); }, []); } }); parcelRequire.register("dlelj", function(module, exports) { $parcel$export(module.exports, "default", () => $9b685cb08303911c$export$2e2bcd8739ae039); function $9b685cb08303911c$export$2e2bcd8739ae039(fn)
                        { var pending; return function() { if (!pending) pending = new Promise(function(resolve) { Promise.resolve().then(function() { pending = undefined; resolve(fn()); }); }); return pending; }; } }); parcelRequire.register("l57aq",
                        function(module, exports) { $parcel$export(module.exports, "default", () => $f58f9fd4551b4b0f$export$2e2bcd8739ae039); function $f58f9fd4551b4b0f$export$2e2bcd8739ae039(modifiers) { var merged = modifiers.reduce(function(merged,
                        current) { var existing = merged[current.name]; merged[current.name] = existing ? Object.assign({}, existing, current, { options: Object.assign({}, existing.options, current.options), data: Object.assign({}, existing.data, current.data)
                        }) : current; return merged; }, {}); // IE11 does not support Object.values return Object.keys(merged).map(function(key) { return merged[key]; }); } }); parcelRequire.register("3tUi5", function(module, exports) { $parcel$export(module.exports,
                        "createPopper", () => $288fbeb449f53487$export$8f7491d57c8f97a9); var $8iXfp = parcelRequire("8iXfp"); var $jU5vk = parcelRequire("jU5vk"); var $cePA2 = parcelRequire("cePA2"); var $5ZHwq = parcelRequire("5ZHwq"); var $aOl9t =
                        parcelRequire("aOl9t"); var $lWzyf = parcelRequire("lWzyf"); var $hMqHB = parcelRequire("hMqHB"); var $bxdrS = parcelRequire("bxdrS"); var $kU5lB = parcelRequire("kU5lB"); var $95q7y = parcelRequire("95q7y"); var $288fbeb449f53487$export$d34966752335dd47
                        = [ (0, $jU5vk.default), (0, $cePA2.default), (0, $5ZHwq.default), (0, $aOl9t.default), (0, $lWzyf.default), (0, $hMqHB.default), (0, $bxdrS.default), (0, $kU5lB.default), (0, $95q7y.default) ]; var $288fbeb449f53487$export$8f7491d57c8f97a9
                        = /*#__PURE__*/ (0, $8iXfp.popperGenerator)({ defaultModifiers: $288fbeb449f53487$export$d34966752335dd47 }); // eslint-disable-next-line import/no-unused-modules }); parcelRequire.register("kznft", function(module, exports) {
                        $parcel$export(module.exports, "createPopper", () => $ef991c361ca719ad$export$8f7491d57c8f97a9); var $8iXfp = parcelRequire("8iXfp"); var $jU5vk = parcelRequire("jU5vk"); var $cePA2 = parcelRequire("cePA2"); var $5ZHwq = parcelRequire("5ZHwq");
                        var $aOl9t = parcelRequire("aOl9t"); var $ef991c361ca719ad$export$d34966752335dd47 = [ (0, $jU5vk.default), (0, $cePA2.default), (0, $5ZHwq.default), (0, $aOl9t.default) ]; var $ef991c361ca719ad$export$8f7491d57c8f97a9 = /*#__PURE__*/
                        (0, $8iXfp.popperGenerator)({ defaultModifiers: $ef991c361ca719ad$export$d34966752335dd47 }); // eslint-disable-next-line import/no-unused-modules }); var $1139d13549d80433$exports = {}; /*! * Bootstrap v5.0.0-beta3 (https://getbootstrap.com/)
                        * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors) * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) */ (function(global, factory) { $1139d13549d80433$exports
                        = factory((parcelRequire("hxwDY"))); })($1139d13549d80433$exports, function(Popper) { "use strict"; function _interopNamespace(e) { if (e && e.__esModule) return e; var n = Object.create(null); if (e) Object.keys(e).forEach(function(k)
                        { if (k !== "default") { var d = Object.getOwnPropertyDescriptor(e, k); Object.defineProperty(n, k, d.get ? d : { enumerable: true, get: function() { return e[k]; } }); } }); n["default"] = e; return Object.freeze(n); } var Popper__namespace
                        = /*#__PURE__*/ _interopNamespace(Popper); /** * -------------------------------------------------------------------------- * Bootstrap (v5.0.0-beta3): util/index.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
                        * -------------------------------------------------------------------------- */ const MAX_UID = 1000000; const MILLISECONDS_MULTIPLIER = 1000; const TRANSITION_END = "transitionend"; // Shoutout AngusCroll (https://goo.gl/pxwQGp)
                        const toType = (obj)=>{ if (obj === null || obj === undefined) return `${obj}`; return ({}).toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase(); }; /** * --------------------------------------------------------------------------
                        * Public Util Api * -------------------------------------------------------------------------- */ const getUID = (prefix)=>{ do prefix += Math.floor(Math.random() * MAX_UID); while (document.getElementById(prefix)); return prefix;
                        }; const getSelector = (element)=>{ let selector = element.getAttribute("data-bs-target"); if (!selector || selector === "#") { let hrefAttr = element.getAttribute("href"); // The only valid content that could double as a selector
                        are IDs or classes, // so everything starting with `#` or `.`. If a "real" URL is used as the selector, // `document.querySelector` will rightfully complain it is invalid. // See https://github.com/twbs/bootstrap/issues/32273 if
                        (!hrefAttr || !hrefAttr.includes("#") && !hrefAttr.startsWith(".")) return null; // Just in case some CMS puts out a full URL with the anchor appended if (hrefAttr.includes("#") && !hrefAttr.startsWith("#")) hrefAttr = "#" + hrefAttr.split("#")[1];
                        selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : null; } return selector; }; const getSelectorFromElement = (element)=>{ const selector = getSelector(element); if (selector) return document.querySelector(selector) ?
                        selector : null; return null; }; const getElementFromSelector = (element)=>{ const selector = getSelector(element); return selector ? document.querySelector(selector) : null; }; const getTransitionDurationFromElement = (element)=>{
                        if (!element) return 0; // Get transition-duration of the element let { transitionDuration: transitionDuration , transitionDelay: transitionDelay } = window.getComputedStyle(element); const floatTransitionDuration = Number.parseFloat(transitionDuration);
                        const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found if (!floatTransitionDuration && !floatTransitionDelay) return 0; // If multiple durations are defined,
                        take the first transitionDuration = transitionDuration.split(",")[0]; transitionDelay = transitionDelay.split(",")[0]; return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
                        }; const triggerTransitionEnd = (element)=>{ element.dispatchEvent(new Event(TRANSITION_END)); }; const isElement = (obj)=>(obj[0] || obj).nodeType; const emulateTransitionEnd = (element, duration)=>{ let called = false; const
                        durationPadding = 5; const emulatedDuration = duration + durationPadding; function listener() { called = true; element.removeEventListener(TRANSITION_END, listener); } element.addEventListener(TRANSITION_END, listener); setTimeout(()=>{
                        if (!called) triggerTransitionEnd(element); }, emulatedDuration); }; const typeCheckConfig = (componentName, config, configTypes)=>{ Object.keys(configTypes).forEach((property)=>{ const expectedTypes = configTypes[property]; const
                        value = config[property]; const valueType = value && isElement(value) ? "element" : toType(value); if (!new RegExp(expectedTypes).test(valueType)) throw new TypeError(`${componentName.toUpperCase()}: ` + `Option "${property}" provided
                        type "${valueType}" ` + `but expected type "${expectedTypes}".`); }); }; const isVisible = (element)=>{ if (!element) return false; if (element.style && element.parentNode && element.parentNode.style) { const elementStyle = getComputedStyle(element);
                        const parentNodeStyle = getComputedStyle(element.parentNode); return elementStyle.display !== "none" && parentNodeStyle.display !== "none" && elementStyle.visibility !== "hidden"; } return false; }; const isDisabled = (element)=>{
                        if (!element || element.nodeType !== Node.ELEMENT_NODE) return true; if (element.classList.contains("disabled")) return true; if (typeof element.disabled !== "undefined") return element.disabled; return element.hasAttribute("disabled")
                        && element.getAttribute("disabled") !== "false"; }; const findShadowRoot = (element)=>{ if (!document.documentElement.attachShadow) return null; // Can find the shadow root otherwise it'll return the document if (typeof element.getRootNode
                        === "function") { const root = element.getRootNode(); return root instanceof ShadowRoot ? root : null; } if (element instanceof ShadowRoot) return element; // when we don't find a shadow root if (!element.parentNode) return null;
                        return findShadowRoot(element.parentNode); }; const noop = ()=>function() {}; const reflow = (element)=>element.offsetHeight; const getjQuery = ()=>{ const { jQuery: jQuery } = window; if (jQuery && !document.body.hasAttribute("data-bs-no-jquery"))
                        return jQuery; return null; }; const onDOMContentLoaded = (callback)=>{ if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", callback); else callback(); }; const isRTL = ()=>document.documentElement.dir
                        === "rtl"; const defineJQueryPlugin = (name, plugin)=>{ onDOMContentLoaded(()=>{ const $ = getjQuery(); /* istanbul ignore if */ if ($) { const JQUERY_NO_CONFLICT = $.fn[name]; $.fn[name] = plugin.jQueryInterface; $.fn[name].Constructor
                        = plugin; $.fn[name].noConflict = ()=>{ $.fn[name] = JQUERY_NO_CONFLICT; return plugin.jQueryInterface; }; } }); }; /** * -------------------------------------------------------------------------- * Bootstrap (v5.0.0-beta3): dom/data.js
                        * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------
                        * Constants * ------------------------------------------------------------------------ */ const elementMap = new Map(); var Data = { set (element, key, instance) { if (!elementMap.has(element)) elementMap.set(element, new Map());
                        const instanceMap = elementMap.get(element); // make it clear we only want one instance per element // can be removed later when multiple key/instances are fine to be used if (!instanceMap.has(key) && instanceMap.size !== 0) {
                        // eslint-disable-next-line no-console console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`); return; } instanceMap.set(key, instance); }, get (element,
                        key) { if (elementMap.has(element)) return elementMap.get(element).get(key) || null; return null; }, remove (element, key) { if (!elementMap.has(element)) return; const instanceMap = elementMap.get(element); instanceMap.delete(key);
                        // free up element references if there are no instances left for an element if (instanceMap.size === 0) elementMap.delete(element); } }; /** * -------------------------------------------------------------------------- * Bootstrap
                        (v5.0.0-beta3): dom/event-handler.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------
                        * Constants * ------------------------------------------------------------------------ */ const namespaceRegex = /[^.]*(?=\..*)\.|.*/; const stripNameRegex = /\..*/; const stripUidRegex = /::\d+$/; const eventRegistry = {}; //
                        Events storage let uidEvent = 1; const customEvents = { mouseenter: "mouseover", mouseleave: "mouseout" }; const nativeEvents = new Set([ "click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll",
                        "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave",
                        "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange",
                        "error", "abort", "scroll" ]); /** * ------------------------------------------------------------------------ * Private methods * ------------------------------------------------------------------------ */ function getUidEvent(element,
                        uid) { return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++; } function getEvent(element) { const uid = getUidEvent(element); element.uidEvent = uid; eventRegistry[uid] = eventRegistry[uid] || {}; return eventRegistry[uid];
                        } function bootstrapHandler(element, fn) { return function handler(event) { event.delegateTarget = element; if (handler.oneOff) EventHandler.off(element, event.type, fn); return fn.apply(element, [ event ]); }; } function bootstrapDelegationHandler(element,
                        selector, fn) { return function handler(event) { const domElements = element.querySelectorAll(selector); for(let { target: target } = event; target && target !== this; target = target.parentNode){ for(let i = domElements.length;
                        i--;)if (domElements[i] === target) { event.delegateTarget = target; if (handler.oneOff) // eslint-disable-next-line unicorn/consistent-destructuring EventHandler.off(element, event.type, fn); return fn.apply(target, [ event ]);
                        } } // To please ESLint return null; }; } function findHandler(events, handler, delegationSelector = null) { const uidEventList = Object.keys(events); for(let i = 0, len = uidEventList.length; i
                        < len; i++){ const event=e vents[uidEventList[i]];
                            if (event.originalHandler===h andler && event.delegationSelector===d elegationSelector) return event; } return null; } function normalizeParams(originalTypeEvent, handler, delegationFn) { const delegation=t ypeof handler==="string"
                            ; const originalHandler=d elegation ? delegationFn : handler; // allow to get the native events from namespaced events ( 'click.bs.button' --> 'click') let typeEvent = originalTypeEvent.replace(stripNameRegex, ""); const custom = customEvents[typeEvent]; if (custom) typeEvent = custom; const isNative = nativeEvents.has(typeEvent); if (!isNative) typeEvent = originalTypeEvent;
                            return [ delegation, originalHandler, typeEvent ]; } function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) { if (typeof originalTypeEvent !== "string" || !element) return; if (!handler) { handler =
                            delegationFn; delegationFn = null; } const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn); const events = getEvent(element); const handlers = events[typeEvent] || (events[typeEvent]
                            = {}); const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null); if (previousFn) { previousFn.oneOff = previousFn.oneOff && oneOff; return; } const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex,
                            "")); const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler); fn.delegationSelector = delegation ? handler : null; fn.originalHandler = originalHandler; fn.oneOff
                            = oneOff; fn.uidEvent = uid; handlers[uid] = fn; element.addEventListener(typeEvent, fn, delegation); } function removeHandler(element, events, typeEvent, handler, delegationSelector) { const fn = findHandler(events[typeEvent],
                            handler, delegationSelector); if (!fn) return; element.removeEventListener(typeEvent, fn, Boolean(delegationSelector)); delete events[typeEvent][fn.uidEvent]; } function removeNamespacedHandlers(element, events, typeEvent,
                            namespace) { const storeElementEvent = events[typeEvent] || {}; Object.keys(storeElementEvent).forEach((handlerKey)=>{ if (handlerKey.includes(namespace)) { const event = storeElementEvent[handlerKey]; removeHandler(element,
                            events, typeEvent, event.originalHandler, event.delegationSelector); } }); } const EventHandler = { on (element, event, handler, delegationFn) { addHandler(element, event, handler, delegationFn, false); }, one (element, event,
                            handler, delegationFn) { addHandler(element, event, handler, delegationFn, true); }, off (element, originalTypeEvent, handler, delegationFn) { if (typeof originalTypeEvent !== "string" || !element) return; const [delegation,
                            originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn); const inNamespace = typeEvent !== originalTypeEvent; const events = getEvent(element); const isNamespace = originalTypeEvent.startsWith(".");
                            if (typeof originalHandler !== "undefined") { // Simplest case: handler is passed, remove that listener ONLY. if (!events || !events[typeEvent]) return; removeHandler(element, events, typeEvent, originalHandler, delegation
                            ? handler : null); return; } if (isNamespace) Object.keys(events).forEach((elementEvent)=>{ removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1)); }); const storeElementEvent = events[typeEvent]
                            || {}; Object.keys(storeElementEvent).forEach((keyHandlers)=>{ const handlerKey = keyHandlers.replace(stripUidRegex, ""); if (!inNamespace || originalTypeEvent.includes(handlerKey)) { const event = storeElementEvent[keyHandlers];
                            removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector); } }); }, trigger (element, event, args) { if (typeof event !== "string" || !element) return null; const $ = getjQuery(); const typeEvent
                            = event.replace(stripNameRegex, ""); const inNamespace = event !== typeEvent; const isNative = nativeEvents.has(typeEvent); let jQueryEvent; let bubbles = true; let nativeDispatch = true; let defaultPrevented = false; let evt
                            = null; if (inNamespace && $) { jQueryEvent = $.Event(event, args); $(element).trigger(jQueryEvent); bubbles = !jQueryEvent.isPropagationStopped(); nativeDispatch = !jQueryEvent.isImmediatePropagationStopped(); defaultPrevented
                            = jQueryEvent.isDefaultPrevented(); } if (isNative) { evt = document.createEvent("HTMLEvents"); evt.initEvent(typeEvent, bubbles, true); } else evt = new CustomEvent(event, { bubbles: bubbles, cancelable: true }); // merge
                            custom information in our event if (typeof args !== "undefined") Object.keys(args).forEach((key)=>{ Object.defineProperty(evt, key, { get () { return args[key]; } }); }); if (defaultPrevented) evt.preventDefault(); if (nativeDispatch)
                            element.dispatchEvent(evt); if (evt.defaultPrevented && typeof jQueryEvent !== "undefined") jQueryEvent.preventDefault(); return evt; } }; /** * -------------------------------------------------------------------------- * Bootstrap
                            (v5.0.0-beta3): base-component.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------
                            * Constants * ------------------------------------------------------------------------ */ const VERSION = "5.0.0-beta3"; class BaseComponent { constructor(element){ element = typeof element === "string" ? document.querySelector(element)
                            : element; if (!element) return; this._element = element; Data.set(this._element, this.constructor.DATA_KEY, this); } dispose() { Data.remove(this._element, this.constructor.DATA_KEY); this._element = null; } /** Static */
                            static getInstance(element) { return Data.get(element, this.DATA_KEY); } static get VERSION() { return VERSION; } } /** * -------------------------------------------------------------------------- * Bootstrap (v5.0.0-beta3):
                            alert.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------
                            * Constants * ------------------------------------------------------------------------ */ const NAME$b = "alert"; const DATA_KEY$b = "bs.alert"; const EVENT_KEY$b = `.${DATA_KEY$b}`; const DATA_API_KEY$8 = ".data-api"; const
                            SELECTOR_DISMISS = '[data-bs-dismiss="alert"]'; const EVENT_CLOSE = `close${EVENT_KEY$b}`; const EVENT_CLOSED = `closed${EVENT_KEY$b}`; const EVENT_CLICK_DATA_API$7 = `click${EVENT_KEY$b}${DATA_API_KEY$8}`; const CLASS_NAME_ALERT
                            = "alert"; const CLASS_NAME_FADE$5 = "fade"; const CLASS_NAME_SHOW$8 = "show"; /** * ------------------------------------------------------------------------ * Class Definition * ------------------------------------------------------------------------
                            */ class Alert extends BaseComponent { // Getters static get DATA_KEY() { return DATA_KEY$b; } close(element) { const rootElement = element ? this._getRootElement(element) : this._element; const customEvent = this._triggerCloseEvent(rootElement);
                            if (customEvent === null || customEvent.defaultPrevented) return; this._removeElement(rootElement); } _getRootElement(element) { return getElementFromSelector(element) || element.closest(`.${CLASS_NAME_ALERT}`); } _triggerCloseEvent(element)
                            { return EventHandler.trigger(element, EVENT_CLOSE); } _removeElement(element) { element.classList.remove(CLASS_NAME_SHOW$8); if (!element.classList.contains(CLASS_NAME_FADE$5)) { this._destroyElement(element); return; } const
                            transitionDuration = getTransitionDurationFromElement(element); EventHandler.one(element, "transitionend", ()=>this._destroyElement(element)); emulateTransitionEnd(element, transitionDuration); } _destroyElement(element) {
                            if (element.parentNode) element.parentNode.removeChild(element); EventHandler.trigger(element, EVENT_CLOSED); } static jQueryInterface(config) { return this.each(function() { let data = Data.get(this, DATA_KEY$b); if (!data)
                            data = new Alert(this); if (config === "close") data[config](this); }); } static handleDismiss(alertInstance) { return function(event) { if (event) event.preventDefault(); alertInstance.close(this); }; } } /** * ------------------------------------------------------------------------
                            * Data Api implementation * ------------------------------------------------------------------------ */ EventHandler.on(document, EVENT_CLICK_DATA_API$7, SELECTOR_DISMISS, Alert.handleDismiss(new Alert())); /** * ------------------------------------------------------------------------
                            * jQuery * ------------------------------------------------------------------------ * add .Alert to jQuery only if jQuery is present */ defineJQueryPlugin(NAME$b, Alert); /** * --------------------------------------------------------------------------
                            * Bootstrap (v5.0.0-beta3): button.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------
                            * Constants * ------------------------------------------------------------------------ */ const NAME$a = "button"; const DATA_KEY$a = "bs.button"; const EVENT_KEY$a = `.${DATA_KEY$a}`; const DATA_API_KEY$7 = ".data-api"; const
                            CLASS_NAME_ACTIVE$3 = "active"; const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]'; const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$7}`; /** * ------------------------------------------------------------------------
                            * Class Definition * ------------------------------------------------------------------------ */ class Button extends BaseComponent { // Getters static get DATA_KEY() { return DATA_KEY$a; } toggle() { // Toggle class and sync
                            the `aria-pressed` attribute with the return value of the `.toggle()` method this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3)); } static jQueryInterface(config) { return this.each(function()
                            { let data = Data.get(this, DATA_KEY$a); if (!data) data = new Button(this); if (config === "toggle") data[config](); }); } } /** * ------------------------------------------------------------------------ * Data Api implementation
                            * ------------------------------------------------------------------------ */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{ event.preventDefault(); const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
                            let data = Data.get(button, DATA_KEY$a); if (!data) data = new Button(button); data.toggle(); }); /** * ------------------------------------------------------------------------ * jQuery * ------------------------------------------------------------------------
                            * add .Button to jQuery only if jQuery is present */ defineJQueryPlugin(NAME$a, Button); /** * -------------------------------------------------------------------------- * Bootstrap (v5.0.0-beta3): dom/manipulator.js * Licensed
                            under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ function normalizeData(val) { if (val === "true") return true; if (val === "false")
                            return false; if (val === Number(val).toString()) return Number(val); if (val === "" || val === "null") return null; return val; } function normalizeDataKey(key) { return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`);
                            } const Manipulator = { setDataAttribute (element, key, value) { element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value); }, removeDataAttribute (element, key) { element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
                            }, getDataAttributes (element) { if (!element) return {}; const attributes = {}; Object.keys(element.dataset).filter((key)=>key.startsWith("bs")).forEach((key)=>{ let pureKey = key.replace(/^bs/, ""); pureKey = pureKey.charAt(0).toLowerCase()
                            + pureKey.slice(1, pureKey.length); attributes[pureKey] = normalizeData(element.dataset[key]); }); return attributes; }, getDataAttribute (element, key) { return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
                            }, offset (element) { const rect = element.getBoundingClientRect(); return { top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft }; }, position (element) { return { top: element.offsetTop, left:
                            element.offsetLeft }; } }; /** * -------------------------------------------------------------------------- * Bootstrap (v5.0.0-beta3): dom/selector-engine.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
                            * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------ * Constants * ------------------------------------------------------------------------
                            */ const NODE_TEXT = 3; const SelectorEngine = { find (selector, element = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(element, selector)); }, findOne (selector, element = document.documentElement)
                            { return Element.prototype.querySelector.call(element, selector); }, children (element, selector) { return [].concat(...element.children).filter((child)=>child.matches(selector)); }, parents (element, selector) { const parents
                            = []; let ancestor = element.parentNode; while(ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT){ if (ancestor.matches(selector)) parents.push(ancestor); ancestor = ancestor.parentNode;
                            } return parents; }, prev (element, selector) { let previous = element.previousElementSibling; while(previous){ if (previous.matches(selector)) return [ previous ]; previous = previous.previousElementSibling; } return []; },
                            next (element, selector) { let next = element.nextElementSibling; while(next){ if (next.matches(selector)) return [ next ]; next = next.nextElementSibling; } return []; } }; /** * --------------------------------------------------------------------------
                            * Bootstrap (v5.0.0-beta3): carousel.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------
                            * Constants * ------------------------------------------------------------------------ */ const NAME$9 = "carousel"; const DATA_KEY$9 = "bs.carousel"; const EVENT_KEY$9 = `.${DATA_KEY$9}`; const DATA_API_KEY$6 = ".data-api";
                            const ARROW_LEFT_KEY = "ArrowLeft"; const ARROW_RIGHT_KEY = "ArrowRight"; const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch const SWIPE_THRESHOLD = 40; const Default$8 = { interval: 5000,
                            keyboard: true, slide: false, pause: "hover", wrap: true, touch: true }; const DefaultType$8 = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch:
                            "boolean" }; const ORDER_NEXT = "next"; const ORDER_PREV = "prev"; const DIRECTION_LEFT = "left"; const DIRECTION_RIGHT = "right"; const EVENT_SLIDE = `slide${EVENT_KEY$9}`; const EVENT_SLID = `slid${EVENT_KEY$9}`; const EVENT_KEYDOWN
                            = `keydown${EVENT_KEY$9}`; const EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$9}`; const EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$9}`; const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`; const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
                            const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`; const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`; const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`; const EVENT_DRAG_START = `dragstart${EVENT_KEY$9}`; const EVENT_LOAD_DATA_API$2
                            = `load${EVENT_KEY$9}${DATA_API_KEY$6}`; const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$9}${DATA_API_KEY$6}`; const CLASS_NAME_CAROUSEL = "carousel"; const CLASS_NAME_ACTIVE$2 = "active"; const CLASS_NAME_SLIDE = "slide";
                            const CLASS_NAME_END = "carousel-item-end"; const CLASS_NAME_START = "carousel-item-start"; const CLASS_NAME_NEXT = "carousel-item-next"; const CLASS_NAME_PREV = "carousel-item-prev"; const CLASS_NAME_POINTER_EVENT = "pointer-event";
                            const SELECTOR_ACTIVE$1 = ".active"; const SELECTOR_ACTIVE_ITEM = ".active.carousel-item"; const SELECTOR_ITEM = ".carousel-item"; const SELECTOR_ITEM_IMG = ".carousel-item img"; const SELECTOR_NEXT_PREV = ".carousel-item-next,
                            .carousel-item-prev"; const SELECTOR_INDICATORS = ".carousel-indicators"; const SELECTOR_INDICATOR = "[data-bs-target]"; const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]"; const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
                            const POINTER_TYPE_TOUCH = "touch"; const POINTER_TYPE_PEN = "pen"; /** * ------------------------------------------------------------------------ * Class Definition * ------------------------------------------------------------------------
                            */ class Carousel extends BaseComponent { constructor(element, config){ super(element); this._items = null; this._interval = null; this._activeElement = null; this._isPaused = false; this._isSliding = false; this.touchTimeout
                            = null; this.touchStartX = 0; this.touchDeltaX = 0; this._config = this._getConfig(config); this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element); this._touchSupported = "ontouchstart" in document.documentElement
                            || navigator.maxTouchPoints > 0; this._pointerEvent = Boolean(window.PointerEvent); this._addEventListeners(); } static get Default() { return Default$8; } static get DATA_KEY() { return DATA_KEY$9; } next() { if (!this._isSliding)
                            this._slide(ORDER_NEXT); } nextWhenVisible() { // Don't call next when the page isn't visible // or the carousel or its parent isn't visible if (!document.hidden && isVisible(this._element)) this.next(); } prev() { if (!this._isSliding)
                            this._slide(ORDER_PREV); } pause(event) { if (!event) this._isPaused = true; if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) { triggerTransitionEnd(this._element); this.cycle(true); } clearInterval(this._interval);
                            this._interval = null; } cycle(event) { if (!event) this._isPaused = false; if (this._interval) { clearInterval(this._interval); this._interval = null; } if (this._config && this._config.interval && !this._isPaused) { this._updateInterval();
                            this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval); } } to(index) { this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
                            const activeIndex = this._getItemIndex(this._activeElement); if (index > this._items.length - 1 || index
                            < 0) return; if (this._isSliding) { EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index)); return; } if (activeIndex === index) { this.pause(); this.cycle(); return; } const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV; this._slide(order, this._items[index]); } dispose() { EventHandler.off(this._element,
                                EVENT_KEY$9); this._items = null; this._config = null; this._interval = null; this._isPaused = null; this._isSliding = null; this._activeElement = null; this._indicatorsElement = null; super.dispose(); } _getConfig(config)
                                { config = { ...Default$8, ...config }; typeCheckConfig(NAME$9, config, DefaultType$8); return config; } _handleSwipe() { const absDeltax = Math.abs(this.touchDeltaX); if (absDeltax
                                <=S WIPE_THRESHOLD) return; const direction=a
                                    bsDeltax / this.touchDeltaX; this.touchDeltaX=0 ; if (!direction) return; this._slide(direction> 0 ? DIRECTION_RIGHT : DIRECTION_LEFT); } _addEventListeners() { if (this._config.keyboard) EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event)); if (this._config.pause === "hover") { EventHandler.on(this._element,
                                    EVENT_MOUSEENTER, (event)=>this.pause(event)); EventHandler.on(this._element, EVENT_MOUSELEAVE, (event)=>this.cycle(event)); } if (this._config.touch && this._touchSupported) this._addTouchEventListeners(); } _addTouchEventListeners()
                                    { const start = (event)=>{ if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) this.touchStartX = event.clientX; else if (!this._pointerEvent) this.touchStartX
                                    = event.touches[0].clientX; }; const move = (event)=>{ // ensure swiping with one touch and not pinching this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;
                                    }; const end = (event)=>{ if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) this.touchDeltaX = event.clientX - this.touchStartX; this._handleSwipe(); if
                                    (this._config.pause === "hover") { // If it's a touch-enabled device, mouseenter/leave are fired as // part of the mouse compatibility events on first tap - the carousel // would stop cycling until user tapped out of
                                    it; // here, we listen for touchend, explicitly pause the carousel // (as if it's the second time we tap on it, mouseenter compat event // is NOT fired) and after a timeout (to allow for mouse compatibility // events
                                    to fire) we explicitly restart cycling this.pause(); if (this.touchTimeout) clearTimeout(this.touchTimeout); this.touchTimeout = setTimeout((event)=>this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
                                    } }; SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach((itemImg)=>{ EventHandler.on(itemImg, EVENT_DRAG_START, (e)=>e.preventDefault()); }); if (this._pointerEvent) { EventHandler.on(this._element, EVENT_POINTERDOWN,
                                    (event)=>start(event)); EventHandler.on(this._element, EVENT_POINTERUP, (event)=>end(event)); this._element.classList.add(CLASS_NAME_POINTER_EVENT); } else { EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>start(event));
                                    EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>move(event)); EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>end(event)); } } _keydown(event) { if (/input|textarea/i.test(event.target.tagName)) return;
                                    if (event.key === ARROW_LEFT_KEY) { event.preventDefault(); this._slide(DIRECTION_LEFT); } else if (event.key === ARROW_RIGHT_KEY) { event.preventDefault(); this._slide(DIRECTION_RIGHT); } } _getItemIndex(element) {
                                    this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : []; return this._items.indexOf(element); } _getItemByOrder(order, activeElement) { const isNext = order === ORDER_NEXT;
                                    const isPrev = order === ORDER_PREV; const activeIndex = this._getItemIndex(activeElement); const lastItemIndex = this._items.length - 1; const isGoingToWrap = isPrev && activeIndex === 0 || isNext && activeIndex ===
                                    lastItemIndex; if (isGoingToWrap && !this._config.wrap) return activeElement; const delta = isPrev ? -1 : 1; const itemIndex = (activeIndex + delta) % this._items.length; return itemIndex === -1 ? this._items[this._items.length
                                    - 1] : this._items[itemIndex]; } _triggerSlideEvent(relatedTarget, eventDirectionName) { const targetIndex = this._getItemIndex(relatedTarget); const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM,
                                    this._element)); return EventHandler.trigger(this._element, EVENT_SLIDE, { relatedTarget: relatedTarget, direction: eventDirectionName, from: fromIndex, to: targetIndex }); } _setActiveIndicatorElement(element) { if
                                    (this._indicatorsElement) { const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement); activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2); activeIndicator.removeAttribute("aria-current");
                                    const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement); for(let i = 0; i
                                    < indicators.length; i++)if (Number.parseInt(indicators[i].getAttribute( "data-bs-slide-to"), 10)===t his._getItemIndex(element))
                                        { indicators[i].classList.add(CLASS_NAME_ACTIVE$2); indicators[i].setAttribute( "aria-current", "true"); break; } } } _updateInterval() { const element=t his._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM,
                                        this._element); if (!element) return; const elementInterval=N umber.parseInt(element.getAttribute( "data-bs-interval"), 10); if (elementInterval) { this._config.defaultInterval=t his._config.defaultInterval || this._config.interval;
                                        this._config.interval=e lementInterval; } else this._config.interval=t his._config.defaultInterval || this._config.interval; } _slide(directionOrOrder, element) { const order=t his._directionToOrder(directionOrOrder);
                                        const activeElement=S electorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element); const activeElementIndex=t his._getItemIndex(activeElement); const nextElement=e lement || this._getItemByOrder(order, activeElement);
                                        const nextElementIndex=t his._getItemIndex(nextElement); const isCycling=B oolean(this._interval); const isNext=o rder===O RDER_NEXT; const directionalClassName=i sNext ? CLASS_NAME_START : CLASS_NAME_END; const orderClassName=i
                                        sNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV; const eventDirectionName=t his._orderToDirection(order); if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) { this._isSliding=f alse; return; } const slideEvent=t
                                        his._triggerSlideEvent(nextElement, eventDirectionName); if (slideEvent.defaultPrevented) return; if (!activeElement || !nextElement) // Some weirdness is happening, so we bail return; this._isSliding=t rue; if (isCycling)
                                        this.pause(); this._setActiveIndicatorElement(nextElement); this._activeElement=n extElement; if (this._element.classList.contains(CLASS_NAME_SLIDE)) { nextElement.classList.add(orderClassName); reflow(nextElement);
                                        activeElement.classList.add(directionalClassName); nextElement.classList.add(directionalClassName); const transitionDuration=g etTransitionDurationFromElement(activeElement); EventHandler.one(activeElement,
                                        "transitionend", ()=>{ nextElement.classList.remove(directionalClassName, orderClassName); nextElement.classList.add(CLASS_NAME_ACTIVE$2); activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName); this._isSliding
                                        = false; setTimeout(()=>{ EventHandler.trigger(this._element, EVENT_SLID, { relatedTarget: nextElement, direction: eventDirectionName, from: activeElementIndex, to: nextElementIndex }); }, 0); }); emulateTransitionEnd(activeElement,
                                        transitionDuration); } else { activeElement.classList.remove(CLASS_NAME_ACTIVE$2); nextElement.classList.add(CLASS_NAME_ACTIVE$2); this._isSliding = false; EventHandler.trigger(this._element, EVENT_SLID, { relatedTarget:
                                        nextElement, direction: eventDirectionName, from: activeElementIndex, to: nextElementIndex }); } if (isCycling) this.cycle(); } _directionToOrder(direction) { if (![ DIRECTION_RIGHT, DIRECTION_LEFT ].includes(direction))
                                        return direction; if (isRTL()) return direction === DIRECTION_RIGHT ? ORDER_PREV : ORDER_NEXT; return direction === DIRECTION_RIGHT ? ORDER_NEXT : ORDER_PREV; } _orderToDirection(order) { if (![ ORDER_NEXT, ORDER_PREV
                                        ].includes(order)) return order; if (isRTL()) return order === ORDER_NEXT ? DIRECTION_LEFT : DIRECTION_RIGHT; return order === ORDER_NEXT ? DIRECTION_RIGHT : DIRECTION_LEFT; } static carouselInterface(element, config)
                                        { let data = Data.get(element, DATA_KEY$9); let _config = { ...Default$8, ...Manipulator.getDataAttributes(element) }; if (typeof config === "object") _config = { ..._config, ...config }; const action = typeof config
                                        === "string" ? config : _config.slide; if (!data) data = new Carousel(element, _config); if (typeof config === "number") data.to(config); else if (typeof action === "string") { if (typeof data[action] === "undefined")
                                        throw new TypeError(`No method named "${action}"`); data[action](); } else if (_config.interval && _config.ride) { data.pause(); data.cycle(); } } static jQueryInterface(config) { return this.each(function() { Carousel.carouselInterface(this,
                                        config); }); } static dataApiClickHandler(event) { const target = getElementFromSelector(this); if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) return; const config = { ...Manipulator.getDataAttributes(target),
                                        ...Manipulator.getDataAttributes(this) }; const slideIndex = this.getAttribute("data-bs-slide-to"); if (slideIndex) config.interval = false; Carousel.carouselInterface(target, config); if (slideIndex) Data.get(target,
                                        DATA_KEY$9).to(slideIndex); event.preventDefault(); } } /** * ------------------------------------------------------------------------ * Data Api implementation * ------------------------------------------------------------------------
                                        */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler); EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{ const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
                                        for(let i = 0, len = carousels.length; i
                                        < len; i++)Carousel.carouselInterface(carousels[i], Data.get(carousels[i], DATA_KEY$9)); }); /** * ------------------------------------------------------------------------
                                            * jQuery * ------------------------------------------------------------------------ * add .Carousel to jQuery only if jQuery is present */ defineJQueryPlugin(NAME$9, Carousel); /** * --------------------------------------------------------------------------
                                            * Bootstrap (v5.0.0-beta3): collapse.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * -------------------------------------------------------------------------- */ /** * ------------------------------------------------------------------------
                                            * Constants * ------------------------------------------------------------------------ */ const NAME$8="collapse" ; const DATA_KEY$8="bs.collapse" ; const EVENT_KEY$8=` .${DATA_KEY$8}`; const DATA_API_KEY$5=".data-api"
                                            ; const Default$7={ toggle: true, parent: "" }; const DefaultType$7={ toggle: "boolean", parent: "(string|element)" }; const EVENT_SHOW$5=` show${EVENT_KEY$8}`; const EVENT_SHOWN$5=` shown${EVENT_KEY$8}`; const
                                            EVENT_HIDE$5=` hide${EVENT_KEY$8}`; const EVENT_HIDDEN$5=` hidden${EVENT_KEY$8}`; const EVENT_CLICK_DATA_API$4=` click${EVENT_KEY$8}${DATA_API_KEY$5}`; const CLASS_NAME_SHOW$7="show" ; const CLASS_NAME_COLLAPSE="collapse"
                                            ; const CLASS_NAME_COLLAPSING="collapsing" ; const CLASS_NAME_COLLAPSED="collapsed" ; const WIDTH="width" ; const HEIGHT="height" ; const SELECTOR_ACTIVES=".show, .collapsing" ; const SELECTOR_DATA_TOGGLE$4='[data-bs-toggle="collapse"]'
                                            ; /** * ------------------------------------------------------------------------ * Class Definition * ------------------------------------------------------------------------ */ class Collapse extends BaseComponent
                                            { constructor(element, config){ super(element); this._isTransitioning=f alse; this._config=t his._getConfig(config); this._triggerArray=S electorEngine.find(`${SELECTOR_DATA_TOGGLE$4}[href="#${this._element.id}"
                                            ],` + `${SELECTOR_DATA_TOGGLE$4}[data-bs-target="#${this._element.id}" ]`); const toggleList=S electorEngine.find(SELECTOR_DATA_TOGGLE$4); for(let i=0 , len=t oggleList.length; i < len; i++){ const elem=t oggleList[i];
                                            const selector=g etSelectorFromElement(elem); const filterElement=S electorEngine.find(selector).filter((foundElem)=>foundElem === this._element); if (selector !== null && filterElement.length) { this._selector = selector; this._triggerArray.push(elem); } } this._parent = this._config.parent ? this._getParent() : null; if (!this._config.parent)
                                            this._addAriaAndCollapsedClass(this._element, this._triggerArray); if (this._config.toggle) this.toggle(); } static get Default() { return Default$7; } static get DATA_KEY() { return DATA_KEY$8; } toggle() {
                                            if (this._element.classList.contains(CLASS_NAME_SHOW$7)) this.hide(); else this.show(); } show() { if (this._isTransitioning || this._element.classList.contains(CLASS_NAME_SHOW$7)) return; let actives; let activesData;
                                            if (this._parent) { actives = SelectorEngine.find(SELECTOR_ACTIVES, this._parent).filter((elem)=>{ if (typeof this._config.parent === "string") return elem.getAttribute("data-bs-parent") === this._config.parent;
                                            return elem.classList.contains(CLASS_NAME_COLLAPSE); }); if (actives.length === 0) actives = null; } const container = SelectorEngine.findOne(this._selector); if (actives) { const tempActiveData = actives.find((elem)=>container
                                            !== elem); activesData = tempActiveData ? Data.get(tempActiveData, DATA_KEY$8) : null; if (activesData && activesData._isTransitioning) return; } const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);
                                            if (startEvent.defaultPrevented) return; if (actives) actives.forEach((elemActive)=>{ if (container !== elemActive) Collapse.collapseInterface(elemActive, "hide"); if (!activesData) Data.set(elemActive, DATA_KEY$8,
                                            null); }); const dimension = this._getDimension(); this._element.classList.remove(CLASS_NAME_COLLAPSE); this._element.classList.add(CLASS_NAME_COLLAPSING); this._element.style[dimension] = 0; if (this._triggerArray.length)
                                            this._triggerArray.forEach((element)=>{ element.classList.remove(CLASS_NAME_COLLAPSED); element.setAttribute("aria-expanded", true); }); this.setTransitioning(true); const complete = ()=>{ this._element.classList.remove(CLASS_NAME_COLLAPSING);
                                            this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7); this._element.style[dimension] = ""; this.setTransitioning(false); EventHandler.trigger(this._element, EVENT_SHOWN$5); }; const capitalizedDimension
                                            = dimension[0].toUpperCase() + dimension.slice(1); const scrollSize = `scroll${capitalizedDimension}`; const transitionDuration = getTransitionDurationFromElement(this._element); EventHandler.one(this._element,
                                            "transitionend", complete); emulateTransitionEnd(this._element, transitionDuration); this._element.style[dimension] = `${this._element[scrollSize]}px`; } hide() { if (this._isTransitioning || !this._element.classList.contains(CLASS_NAME_SHOW$7))
                                            return; const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5); if (startEvent.defaultPrevented) return; const dimension = this._getDimension(); this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
                                            reflow(this._element); this._element.classList.add(CLASS_NAME_COLLAPSING); this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7); const triggerArrayLength = this._triggerArray.length; if (triggerArrayLength
                                            > 0) for(let i = 0; i
                                            < triggerArrayLength; i++){ const trigger=t his._triggerArray[i]; const elem=g etElementFromSelector(trigger); if (elem && !elem.classList.contains(CLASS_NAME_SHOW$7)) { trigger.classList.add(CLASS_NAME_COLLAPSED);
                                                trigger.setAttribute( "aria-expanded", false); } } this.setTransitioning(true); const complete=( )=>{ this.setTransitioning(false); this._element.classList.remove(CLASS_NAME_COLLAPSING); this._element.classList.add(CLASS_NAME_COLLAPSE); EventHandler.trigger(this._element, EVENT_HIDDEN$5); }; this._element.style[dimension]
                                                = ""; const transitionDuration = getTransitionDurationFromElement(this._element); EventHandler.one(this._element, "transitionend", complete); emulateTransitionEnd(this._element, transitionDuration); } setTransitioning(isTransitioning)
                                                { this._isTransitioning = isTransitioning; } dispose() { super.dispose(); this._config = null; this._parent = null; this._triggerArray = null; this._isTransitioning = null; } _getConfig(config) { config
                                                = { ...Default$7, ...config }; config.toggle = Boolean(config.toggle); // Coerce string values typeCheckConfig(NAME$8, config, DefaultType$7); return config; } _getDimension() { return this._element.classList.contains(WIDTH)
                                                ? WIDTH : HEIGHT; } _getParent() { let { parent: parent } = this._config; if (isElement(parent)) // it's a jQuery object { if (typeof parent.jquery !== "undefined" || typeof parent[0] !== "undefined") parent
                                                = parent[0]; } else parent = SelectorEngine.findOne(parent); const selector = `${SELECTOR_DATA_TOGGLE$4}[data-bs-parent="${parent}"]`; SelectorEngine.find(selector, parent).forEach((element)=>{ const selected
                                                = getElementFromSelector(element); this._addAriaAndCollapsedClass(selected, [ element ]); }); return parent; } _addAriaAndCollapsedClass(element, triggerArray) { if (!element || !triggerArray.length) return;
                                                const isOpen = element.classList.contains(CLASS_NAME_SHOW$7); triggerArray.forEach((elem)=>{ if (isOpen) elem.classList.remove(CLASS_NAME_COLLAPSED); else elem.classList.add(CLASS_NAME_COLLAPSED); elem.setAttribute("aria-expanded",
                                                isOpen); }); } static collapseInterface(element, config) { let data = Data.get(element, DATA_KEY$8); const _config = { ...Default$7, ...Manipulator.getDataAttributes(element), ...typeof config === "object"
                                                && config ? config : {} }; if (!data && _config.toggle && typeof config === "string" && /show|hide/.test(config)) _config.toggle = false; if (!data) data = new Collapse(element, _config); if (typeof config
                                                === "string") { if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`); data[config](); } } static jQueryInterface(config) { return this.each(function() { Collapse.collapseInterface(this,
                                                config); }); } } /** * ------------------------------------------------------------------------ * Data Api implementation * ------------------------------------------------------------------------ */ EventHandler.on(document,
                                                EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) { // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
        if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") event.preventDefault();
        const triggerData = Manipulator.getDataAttributes(this);
        const selector = getSelectorFromElement(this);
        const selectorElements = SelectorEngine.find(selector);
        selectorElements.forEach((element)=>{
            const data = Data.get(element, DATA_KEY$8);
            let config;
            if (data) {
                // update parent attribute
                if (data._parent === null && typeof triggerData.parent === "string") {
                    data._config.parent = triggerData.parent;
                    data._parent = data._getParent();
                }
                config = "toggle";
            } else config = triggerData;
            Collapse.collapseInterface(element, config);
        });
    });
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Collapse to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME$8, Collapse);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME$7 = "dropdown";
    const DATA_KEY$7 = "bs.dropdown";
    const EVENT_KEY$7 = `.${DATA_KEY$7}`;
    const DATA_API_KEY$4 = ".data-api";
    const ESCAPE_KEY$2 = "Escape";
    const SPACE_KEY = "Space";
    const TAB_KEY = "Tab";
    const ARROW_UP_KEY = "ArrowUp";
    const ARROW_DOWN_KEY = "ArrowDown";
    const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button
    const REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);
    const EVENT_HIDE$4 = `hide${EVENT_KEY$7}`;
    const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$7}`;
    const EVENT_SHOW$4 = `show${EVENT_KEY$7}`;
    const EVENT_SHOWN$4 = `shown${EVENT_KEY$7}`;
    const EVENT_CLICK = `click${EVENT_KEY$7}`;
    const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
    const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$7}${DATA_API_KEY$4}`;
    const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$7}${DATA_API_KEY$4}`;
    const CLASS_NAME_DISABLED = "disabled";
    const CLASS_NAME_SHOW$6 = "show";
    const CLASS_NAME_DROPUP = "dropup";
    const CLASS_NAME_DROPEND = "dropend";
    const CLASS_NAME_DROPSTART = "dropstart";
    const CLASS_NAME_NAVBAR = "navbar";
    const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]';
    const SELECTOR_MENU = ".dropdown-menu";
    const SELECTOR_NAVBAR_NAV = ".navbar-nav";
    const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
    const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
    const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
    const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
    const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
    const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
    const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
    const Default$6 = {
        offset: [
            0,
            2
        ],
        boundary: "clippingParents",
        reference: "toggle",
        display: "dynamic",
        popperConfig: null
    };
    const DefaultType$6 = {
        offset: "(array|string|function)",
        boundary: "(string|element)",
        reference: "(string|element|object)",
        display: "string",
        popperConfig: "(null|object|function)"
    };
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class Dropdown extends BaseComponent {
        constructor(element, config){
            super(element);
            this._popper = null;
            this._config = this._getConfig(config);
            this._menu = this._getMenuElement();
            this._inNavbar = this._detectNavbar();
            this._addEventListeners();
        }
        static get Default() {
            return Default$6;
        }
        static get DefaultType() {
            return DefaultType$6;
        }
        static get DATA_KEY() {
            return DATA_KEY$7;
        }
        toggle() {
            if (this._element.disabled || this._element.classList.contains(CLASS_NAME_DISABLED)) return;
            const isActive = this._element.classList.contains(CLASS_NAME_SHOW$6);
            Dropdown.clearMenus();
            if (isActive) return;
            this.show();
        }
        show() {
            if (this._element.disabled || this._element.classList.contains(CLASS_NAME_DISABLED) || this._menu.classList.contains(CLASS_NAME_SHOW$6)) return;
            const parent = Dropdown.getParentFromElement(this._element);
            const relatedTarget = {
                relatedTarget: this._element
            };
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);
            if (showEvent.defaultPrevented) return;
             // Totally disable Popper for Dropdowns in Navbar
            if (this._inNavbar) Manipulator.setDataAttribute(this._menu, "popper", "none");
            else {
                if (typeof Popper__namespace === "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                let referenceElement = this._element;
                if (this._config.reference === "parent") referenceElement = parent;
                else if (isElement(this._config.reference)) {
                    referenceElement = this._config.reference; // Check if it's jQuery element
                    if (typeof this._config.reference.jquery !== "undefined") referenceElement = this._config.reference[0];
                } else if (typeof this._config.reference === "object") referenceElement = this._config.reference;
                const popperConfig = this._getPopperConfig();
                const isDisplayStatic = popperConfig.modifiers.find((modifier)=>modifier.name === "applyStyles" && modifier.enabled === false);
                this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);
                if (isDisplayStatic) Manipulator.setDataAttribute(this._menu, "popper", "static");
            } // If this is a touch-enabled device we add extra
            // empty mouseover listeners to the body's immediate children;
            // only needed because of broken event delegation on iOS
            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
            if ("ontouchstart" in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) [].concat(...document.body.children).forEach((elem)=>EventHandler.on(elem, "mouseover", null, noop()));
            this._element.focus();
            this._element.setAttribute("aria-expanded", true);
            this._menu.classList.toggle(CLASS_NAME_SHOW$6);
            this._element.classList.toggle(CLASS_NAME_SHOW$6);
            EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);
        }
        hide() {
            if (this._element.disabled || this._element.classList.contains(CLASS_NAME_DISABLED) || !this._menu.classList.contains(CLASS_NAME_SHOW$6)) return;
            const relatedTarget = {
                relatedTarget: this._element
            };
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);
            if (hideEvent.defaultPrevented) return;
            if (this._popper) this._popper.destroy();
            this._menu.classList.toggle(CLASS_NAME_SHOW$6);
            this._element.classList.toggle(CLASS_NAME_SHOW$6);
            Manipulator.removeDataAttribute(this._menu, "popper");
            EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);
        }
        dispose() {
            EventHandler.off(this._element, EVENT_KEY$7);
            this._menu = null;
            if (this._popper) {
                this._popper.destroy();
                this._popper = null;
            }
            super.dispose();
        }
        update() {
            this._inNavbar = this._detectNavbar();
            if (this._popper) this._popper.update();
        }
        _addEventListeners() {
            EventHandler.on(this._element, EVENT_CLICK, (event)=>{
                event.preventDefault();
                this.toggle();
            });
        }
        _getConfig(config) {
            config = {
                ...this.constructor.Default,
                ...Manipulator.getDataAttributes(this._element),
                ...config
            };
            typeCheckConfig(NAME$7, config, this.constructor.DefaultType);
            if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") // Popper virtual elements require a getBoundingClientRect method
            throw new TypeError(`${NAME$7.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            return config;
        }
        _getMenuElement() {
            return SelectorEngine.next(this._element, SELECTOR_MENU)[0];
        }
        _getPlacement() {
            const parentDropdown = this._element.parentNode;
            if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) return PLACEMENT_RIGHT;
            if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) return PLACEMENT_LEFT;
             // We need to trim the value because custom properties can also include spaces
            const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
            return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
        }
        _detectNavbar() {
            return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;
        }
        _getOffset() {
            const { offset: offset  } = this._config;
            if (typeof offset === "string") return offset.split(",").map((val)=>Number.parseInt(val, 10));
            if (typeof offset === "function") return (popperData)=>offset(popperData, this._element);
            return offset;
        }
        _getPopperConfig() {
            const defaultBsPopperConfig = {
                placement: this._getPlacement(),
                modifiers: [
                    {
                        name: "preventOverflow",
                        options: {
                            boundary: this._config.boundary
                        }
                    },
                    {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    }
                ]
            }; // Disable Popper if we have a static display
            if (this._config.display === "static") defaultBsPopperConfig.modifiers = [
                {
                    name: "applyStyles",
                    enabled: false
                }
            ];
            return {
                ...defaultBsPopperConfig,
                ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
            };
        }
        static dropdownInterface(element, config) {
            let data = Data.get(element, DATA_KEY$7);
            const _config = typeof config === "object" ? config : null;
            if (!data) data = new Dropdown(element, _config);
            if (typeof config === "string") {
                if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        }
        static jQueryInterface(config) {
            return this.each(function() {
                Dropdown.dropdownInterface(this, config);
            });
        }
        static clearMenus(event) {
            if (event) {
                if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY) return;
                if (/input|select|textarea|form/i.test(event.target.tagName)) return;
            }
            const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);
            for(let i = 0, len = toggles.length; i < len; i++){
                const context = Data.get(toggles[i], DATA_KEY$7);
                const relatedTarget = {
                    relatedTarget: toggles[i]
                };
                if (event && event.type === "click") relatedTarget.clickEvent = event;
                if (!context) continue;
                const dropdownMenu = context._menu;
                if (!toggles[i].classList.contains(CLASS_NAME_SHOW$6)) continue;
                if (event) {
                    // Don't close the menu if the clicked element or one of its parents is the dropdown button
                    if ([
                        context._element
                    ].some((element)=>event.composedPath().includes(element))) continue;
                     // Tab navigation through the dropdown menu shouldn't close the menu
                    if (event.type === "keyup" && event.key === TAB_KEY && dropdownMenu.contains(event.target)) continue;
                }
                const hideEvent = EventHandler.trigger(toggles[i], EVENT_HIDE$4, relatedTarget);
                if (hideEvent.defaultPrevented) continue;
                 // If this is a touch-enabled device we remove the extra
                // empty mouseover listeners we added for iOS support
                if ("ontouchstart" in document.documentElement) [].concat(...document.body.children).forEach((elem)=>EventHandler.off(elem, "mouseover", null, noop()));
                toggles[i].setAttribute("aria-expanded", "false");
                if (context._popper) context._popper.destroy();
                dropdownMenu.classList.remove(CLASS_NAME_SHOW$6);
                toggles[i].classList.remove(CLASS_NAME_SHOW$6);
                Manipulator.removeDataAttribute(dropdownMenu, "popper");
                EventHandler.trigger(toggles[i], EVENT_HIDDEN$4, relatedTarget);
            }
        }
        static getParentFromElement(element) {
            return getElementFromSelector(element) || element.parentNode;
        }
        static dataApiKeydownHandler(event) {
            // If not input/textarea:
            //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
            // If input/textarea:
            //  - If space key => not a dropdown command
            //  - If key is other than escape
            //    - If key is not up or down => not a dropdown command
            //    - If trigger inside the menu => not a dropdown command
            if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) return;
            event.preventDefault();
            event.stopPropagation();
            if (this.disabled || this.classList.contains(CLASS_NAME_DISABLED)) return;
            const parent = Dropdown.getParentFromElement(this);
            const isActive = this.classList.contains(CLASS_NAME_SHOW$6);
            if (event.key === ESCAPE_KEY$2) {
                const button = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
                button.focus();
                Dropdown.clearMenus();
                return;
            }
            if (!isActive && (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY)) {
                const button = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
                button.click();
                return;
            }
            if (!isActive || event.key === SPACE_KEY) {
                Dropdown.clearMenus();
                return;
            }
            const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, parent).filter(isVisible);
            if (!items.length) return;
            let index = items.indexOf(event.target); // Up
            if (event.key === ARROW_UP_KEY && index > 0) index--;
             // Down
            if (event.key === ARROW_DOWN_KEY && index < items.length - 1) index++;
             // index is -1 if the first keydown is an ArrowUp
            index = index === -1 ? 0 : index;
            items[index].focus();
        }
    }
    /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
    EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
    EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
    EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
    EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
        event.preventDefault();
        Dropdown.dropdownInterface(this);
    });
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Dropdown to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME$7, Dropdown);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME$6 = "modal";
    const DATA_KEY$6 = "bs.modal";
    const EVENT_KEY$6 = `.${DATA_KEY$6}`;
    const DATA_API_KEY$3 = ".data-api";
    const ESCAPE_KEY$1 = "Escape";
    const Default$5 = {
        backdrop: true,
        keyboard: true,
        focus: true
    };
    const DefaultType$5 = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        focus: "boolean"
    };
    const EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;
    const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;
    const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;
    const EVENT_SHOW$3 = `show${EVENT_KEY$6}`;
    const EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;
    const EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$6}`;
    const EVENT_RESIZE = `resize${EVENT_KEY$6}`;
    const EVENT_CLICK_DISMISS$2 = `click.dismiss${EVENT_KEY$6}`;
    const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$6}`;
    const EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;
    const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;
    const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
    const CLASS_NAME_SCROLLBAR_MEASURER = "modal-scrollbar-measure";
    const CLASS_NAME_BACKDROP = "modal-backdrop";
    const CLASS_NAME_OPEN = "modal-open";
    const CLASS_NAME_FADE$4 = "fade";
    const CLASS_NAME_SHOW$5 = "show";
    const CLASS_NAME_STATIC = "modal-static";
    const SELECTOR_DIALOG = ".modal-dialog";
    const SELECTOR_MODAL_BODY = ".modal-body";
    const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
    const SELECTOR_DATA_DISMISS$2 = '[data-bs-dismiss="modal"]';
    const SELECTOR_FIXED_CONTENT$1 = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
    const SELECTOR_STICKY_CONTENT$1 = ".sticky-top";
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class Modal extends BaseComponent {
        constructor(element, config){
            super(element);
            this._config = this._getConfig(config);
            this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
            this._backdrop = null;
            this._isShown = false;
            this._isBodyOverflowing = false;
            this._ignoreBackdropClick = false;
            this._isTransitioning = false;
            this._scrollbarWidth = 0;
        }
        static get Default() {
            return Default$5;
        }
        static get DATA_KEY() {
            return DATA_KEY$6;
        }
        toggle(relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget);
        }
        show(relatedTarget) {
            if (this._isShown || this._isTransitioning) return;
            if (this._isAnimated()) this._isTransitioning = true;
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
                relatedTarget: relatedTarget
            });
            if (this._isShown || showEvent.defaultPrevented) return;
            this._isShown = true;
            this._checkScrollbar();
            this._setScrollbar();
            this._adjustDialog();
            this._setEscapeEvent();
            this._setResizeEvent();
            EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, SELECTOR_DATA_DISMISS$2, (event)=>this.hide(event));
            EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, ()=>{
                EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, (event)=>{
                    if (event.target === this._element) this._ignoreBackdropClick = true;
                });
            });
            this._showBackdrop(()=>this._showElement(relatedTarget));
        }
        hide(event) {
            if (event) event.preventDefault();
            if (!this._isShown || this._isTransitioning) return;
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
            if (hideEvent.defaultPrevented) return;
            this._isShown = false;
            const isAnimated = this._isAnimated();
            if (isAnimated) this._isTransitioning = true;
            this._setEscapeEvent();
            this._setResizeEvent();
            EventHandler.off(document, EVENT_FOCUSIN$1);
            this._element.classList.remove(CLASS_NAME_SHOW$5);
            EventHandler.off(this._element, EVENT_CLICK_DISMISS$2);
            EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);
            if (isAnimated) {
                const transitionDuration = getTransitionDurationFromElement(this._element);
                EventHandler.one(this._element, "transitionend", (event)=>this._hideModal(event));
                emulateTransitionEnd(this._element, transitionDuration);
            } else this._hideModal();
        }
        dispose() {
            [
                window,
                this._element,
                this._dialog
            ].forEach((htmlElement)=>EventHandler.off(htmlElement, EVENT_KEY$6));
            super.dispose();
            /**
       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `EVENT_CLICK_DATA_API` event that should remain
       */ EventHandler.off(document, EVENT_FOCUSIN$1);
            this._config = null;
            this._dialog = null;
            this._backdrop = null;
            this._isShown = null;
            this._isBodyOverflowing = null;
            this._ignoreBackdropClick = null;
            this._isTransitioning = null;
            this._scrollbarWidth = null;
        }
        handleUpdate() {
            this._adjustDialog();
        }
        _getConfig(config) {
            config = {
                ...Default$5,
                ...config
            };
            typeCheckConfig(NAME$6, config, DefaultType$5);
            return config;
        }
        _showElement(relatedTarget) {
            const isAnimated = this._isAnimated();
            const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
            if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) // Don't move modal's DOM position
            document.body.appendChild(this._element);
            this._element.style.display = "block";
            this._element.removeAttribute("aria-hidden");
            this._element.setAttribute("aria-modal", true);
            this._element.setAttribute("role", "dialog");
            this._element.scrollTop = 0;
            if (modalBody) modalBody.scrollTop = 0;
            if (isAnimated) reflow(this._element);
            this._element.classList.add(CLASS_NAME_SHOW$5);
            if (this._config.focus) this._enforceFocus();
            const transitionComplete = ()=>{
                if (this._config.focus) this._element.focus();
                this._isTransitioning = false;
                EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                    relatedTarget: relatedTarget
                });
            };
            if (isAnimated) {
                const transitionDuration = getTransitionDurationFromElement(this._dialog);
                EventHandler.one(this._dialog, "transitionend", transitionComplete);
                emulateTransitionEnd(this._dialog, transitionDuration);
            } else transitionComplete();
        }
        _enforceFocus() {
            EventHandler.off(document, EVENT_FOCUSIN$1); // guard against infinite focus loop
            EventHandler.on(document, EVENT_FOCUSIN$1, (event)=>{
                if (document !== event.target && this._element !== event.target && !this._element.contains(event.target)) this._element.focus();
            });
        }
        _setEscapeEvent() {
            if (this._isShown) EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{
                if (this._config.keyboard && event.key === ESCAPE_KEY$1) {
                    event.preventDefault();
                    this.hide();
                } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) this._triggerBackdropTransition();
            });
            else EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS);
        }
        _setResizeEvent() {
            if (this._isShown) EventHandler.on(window, EVENT_RESIZE, ()=>this._adjustDialog());
            else EventHandler.off(window, EVENT_RESIZE);
        }
        _hideModal() {
            this._element.style.display = "none";
            this._element.setAttribute("aria-hidden", true);
            this._element.removeAttribute("aria-modal");
            this._element.removeAttribute("role");
            this._isTransitioning = false;
            this._showBackdrop(()=>{
                document.body.classList.remove(CLASS_NAME_OPEN);
                this._resetAdjustments();
                this._resetScrollbar();
                EventHandler.trigger(this._element, EVENT_HIDDEN$3);
            });
        }
        _removeBackdrop() {
            this._backdrop.parentNode.removeChild(this._backdrop);
            this._backdrop = null;
        }
        _showBackdrop(callback) {
            const isAnimated = this._isAnimated();
            if (this._isShown && this._config.backdrop) {
                this._backdrop = document.createElement("div");
                this._backdrop.className = CLASS_NAME_BACKDROP;
                if (isAnimated) this._backdrop.classList.add(CLASS_NAME_FADE$4);
                document.body.appendChild(this._backdrop);
                EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, (event)=>{
                    if (this._ignoreBackdropClick) {
                        this._ignoreBackdropClick = false;
                        return;
                    }
                    if (event.target !== event.currentTarget) return;
                    if (this._config.backdrop === "static") this._triggerBackdropTransition();
                    else this.hide();
                });
                if (isAnimated) reflow(this._backdrop);
                this._backdrop.classList.add(CLASS_NAME_SHOW$5);
                if (!isAnimated) {
                    callback();
                    return;
                }
                const backdropTransitionDuration = getTransitionDurationFromElement(this._backdrop);
                EventHandler.one(this._backdrop, "transitionend", callback);
                emulateTransitionEnd(this._backdrop, backdropTransitionDuration);
            } else if (!this._isShown && this._backdrop) {
                this._backdrop.classList.remove(CLASS_NAME_SHOW$5);
                const callbackRemove = ()=>{
                    this._removeBackdrop();
                    callback();
                };
                if (isAnimated) {
                    const backdropTransitionDuration = getTransitionDurationFromElement(this._backdrop);
                    EventHandler.one(this._backdrop, "transitionend", callbackRemove);
                    emulateTransitionEnd(this._backdrop, backdropTransitionDuration);
                } else callbackRemove();
            } else callback();
        }
        _isAnimated() {
            return this._element.classList.contains(CLASS_NAME_FADE$4);
        }
        _triggerBackdropTransition() {
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
            if (hideEvent.defaultPrevented) return;
            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            if (!isModalOverflowing) this._element.style.overflowY = "hidden";
            this._element.classList.add(CLASS_NAME_STATIC);
            const modalTransitionDuration = getTransitionDurationFromElement(this._dialog);
            EventHandler.off(this._element, "transitionend");
            EventHandler.one(this._element, "transitionend", ()=>{
                this._element.classList.remove(CLASS_NAME_STATIC);
                if (!isModalOverflowing) {
                    EventHandler.one(this._element, "transitionend", ()=>{
                        this._element.style.overflowY = "";
                    });
                    emulateTransitionEnd(this._element, modalTransitionDuration);
                }
            });
            emulateTransitionEnd(this._element, modalTransitionDuration);
            this._element.focus();
        }
        // the following methods are used to handle overflowing modals
        // ----------------------------------------------------------------------
        _adjustDialog() {
            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            if (!this._isBodyOverflowing && isModalOverflowing && !isRTL() || this._isBodyOverflowing && !isModalOverflowing && isRTL()) this._element.style.paddingLeft = `${this._scrollbarWidth}px`;
            if (this._isBodyOverflowing && !isModalOverflowing && !isRTL() || !this._isBodyOverflowing && isModalOverflowing && isRTL()) this._element.style.paddingRight = `${this._scrollbarWidth}px`;
        }
        _resetAdjustments() {
            this._element.style.paddingLeft = "";
            this._element.style.paddingRight = "";
        }
        _checkScrollbar() {
            const rect = document.body.getBoundingClientRect();
            this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
            this._scrollbarWidth = this._getScrollbarWidth();
        }
        _setScrollbar() {
            if (this._isBodyOverflowing) {
                this._setElementAttributes(SELECTOR_FIXED_CONTENT$1, "paddingRight", (calculatedValue)=>calculatedValue + this._scrollbarWidth);
                this._setElementAttributes(SELECTOR_STICKY_CONTENT$1, "marginRight", (calculatedValue)=>calculatedValue - this._scrollbarWidth);
                this._setElementAttributes("body", "paddingRight", (calculatedValue)=>calculatedValue + this._scrollbarWidth);
            }
            document.body.classList.add(CLASS_NAME_OPEN);
        }
        _setElementAttributes(selector, styleProp, callback) {
            SelectorEngine.find(selector).forEach((element)=>{
                if (element !== document.body && window.innerWidth > element.clientWidth + this._scrollbarWidth) return;
                const actualValue = element.style[styleProp];
                const calculatedValue = window.getComputedStyle(element)[styleProp];
                Manipulator.setDataAttribute(element, styleProp, actualValue);
                element.style[styleProp] = callback(Number.parseFloat(calculatedValue)) + "px";
            });
        }
        _resetScrollbar() {
            this._resetElementAttributes(SELECTOR_FIXED_CONTENT$1, "paddingRight");
            this._resetElementAttributes(SELECTOR_STICKY_CONTENT$1, "marginRight");
            this._resetElementAttributes("body", "paddingRight");
        }
        _resetElementAttributes(selector, styleProp) {
            SelectorEngine.find(selector).forEach((element)=>{
                const value = Manipulator.getDataAttribute(element, styleProp);
                if (typeof value === "undefined" && element === document.body) element.style[styleProp] = "";
                else {
                    Manipulator.removeDataAttribute(element, styleProp);
                    element.style[styleProp] = value;
                }
            });
        }
        _getScrollbarWidth() {
            // thx d.walsh
            const scrollDiv = document.createElement("div");
            scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
            document.body.appendChild(scrollDiv);
            const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
            document.body.removeChild(scrollDiv);
            return scrollbarWidth;
        }
        static jQueryInterface(config, relatedTarget) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$6);
                const _config = {
                    ...Default$5,
                    ...Manipulator.getDataAttributes(this),
                    ...typeof config === "object" && config ? config : {}
                };
                if (!data) data = new Modal(this, _config);
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                    data[config](relatedTarget);
                }
            });
        }
    }
    /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
        const target = getElementFromSelector(this);
        if (this.tagName === "A" || this.tagName === "AREA") event.preventDefault();
        EventHandler.one(target, EVENT_SHOW$3, (showEvent)=>{
            if (showEvent.defaultPrevented) // only register focus restorer if modal will actually get shown
            return;
            EventHandler.one(target, EVENT_HIDDEN$3, ()=>{
                if (isVisible(this)) this.focus();
            });
        });
        let data = Data.get(target, DATA_KEY$6);
        if (!data) {
            const config = {
                ...Manipulator.getDataAttributes(target),
                ...Manipulator.getDataAttributes(this)
            };
            data = new Modal(target, config);
        }
        data.toggle(this);
    });
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Modal to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME$6, Modal);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed";
    const SELECTOR_STICKY_CONTENT = ".sticky-top";
    const getWidth = ()=>{
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        const documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
    };
    const hide = (width = getWidth())=>{
        document.body.style.overflow = "hidden";
        _setElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight", (calculatedValue)=>calculatedValue + width);
        _setElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight", (calculatedValue)=>calculatedValue - width);
        _setElementAttributes("body", "paddingRight", (calculatedValue)=>calculatedValue + width);
    };
    const _setElementAttributes = (selector, styleProp, callback)=>{
        const scrollbarWidth = getWidth();
        SelectorEngine.find(selector).forEach((element)=>{
            if (element !== document.body && window.innerWidth > element.clientWidth + scrollbarWidth) return;
            const actualValue = element.style[styleProp];
            const calculatedValue = window.getComputedStyle(element)[styleProp];
            Manipulator.setDataAttribute(element, styleProp, actualValue);
            element.style[styleProp] = callback(Number.parseFloat(calculatedValue)) + "px";
        });
    };
    const reset = ()=>{
        document.body.style.overflow = "auto";
        _resetElementAttributes(SELECTOR_FIXED_CONTENT, "paddingRight");
        _resetElementAttributes(SELECTOR_STICKY_CONTENT, "marginRight");
        _resetElementAttributes("body", "paddingRight");
    };
    const _resetElementAttributes = (selector, styleProp)=>{
        SelectorEngine.find(selector).forEach((element)=>{
            const value = Manipulator.getDataAttribute(element, styleProp);
            if (typeof value === "undefined" && element === document.body) element.style.removeProperty(styleProp);
            else {
                Manipulator.removeDataAttribute(element, styleProp);
                element.style[styleProp] = value;
            }
        });
    };
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): offcanvas.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME$5 = "offcanvas";
    const DATA_KEY$5 = "bs.offcanvas";
    const EVENT_KEY$5 = `.${DATA_KEY$5}`;
    const DATA_API_KEY$2 = ".data-api";
    const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;
    const ESCAPE_KEY = "Escape";
    const Default$4 = {
        backdrop: true,
        keyboard: true,
        scroll: false
    };
    const DefaultType$4 = {
        backdrop: "boolean",
        keyboard: "boolean",
        scroll: "boolean"
    };
    const CLASS_NAME_BACKDROP_BODY = "offcanvas-backdrop";
    const CLASS_NAME_SHOW$4 = "show";
    const CLASS_NAME_TOGGLING = "offcanvas-toggling";
    const OPEN_SELECTOR = ".offcanvas.show";
    const ACTIVE_SELECTOR = `${OPEN_SELECTOR}, .${CLASS_NAME_TOGGLING}`;
    const EVENT_SHOW$2 = `show${EVENT_KEY$5}`;
    const EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;
    const EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;
    const EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;
    const EVENT_FOCUSIN = `focusin${EVENT_KEY$5}`;
    const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;
    const EVENT_CLICK_DISMISS$1 = `click.dismiss${EVENT_KEY$5}`;
    const SELECTOR_DATA_DISMISS$1 = '[data-bs-dismiss="offcanvas"]';
    const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class Offcanvas extends BaseComponent {
        constructor(element, config){
            super(element);
            this._config = this._getConfig(config);
            this._isShown = false;
            this._addEventListeners();
        }
        static get Default() {
            return Default$4;
        }
        static get DATA_KEY() {
            return DATA_KEY$5;
        }
        toggle(relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget);
        }
        show(relatedTarget) {
            if (this._isShown) return;
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {
                relatedTarget: relatedTarget
            });
            if (showEvent.defaultPrevented) return;
            this._isShown = true;
            this._element.style.visibility = "visible";
            if (this._config.backdrop) document.body.classList.add(CLASS_NAME_BACKDROP_BODY);
            if (!this._config.scroll) hide();
            this._element.classList.add(CLASS_NAME_TOGGLING);
            this._element.removeAttribute("aria-hidden");
            this._element.setAttribute("aria-modal", true);
            this._element.setAttribute("role", "dialog");
            this._element.classList.add(CLASS_NAME_SHOW$4);
            const completeCallBack = ()=>{
                this._element.classList.remove(CLASS_NAME_TOGGLING);
                EventHandler.trigger(this._element, EVENT_SHOWN$2, {
                    relatedTarget: relatedTarget
                });
                this._enforceFocusOnElement(this._element);
            };
            setTimeout(completeCallBack, getTransitionDurationFromElement(this._element));
        }
        hide() {
            if (!this._isShown) return;
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);
            if (hideEvent.defaultPrevented) return;
            this._element.classList.add(CLASS_NAME_TOGGLING);
            EventHandler.off(document, EVENT_FOCUSIN);
            this._element.blur();
            this._isShown = false;
            this._element.classList.remove(CLASS_NAME_SHOW$4);
            const completeCallback = ()=>{
                this._element.setAttribute("aria-hidden", true);
                this._element.removeAttribute("aria-modal");
                this._element.removeAttribute("role");
                this._element.style.visibility = "hidden";
                if (this._config.backdrop) document.body.classList.remove(CLASS_NAME_BACKDROP_BODY);
                if (!this._config.scroll) reset();
                EventHandler.trigger(this._element, EVENT_HIDDEN$2);
                this._element.classList.remove(CLASS_NAME_TOGGLING);
            };
            setTimeout(completeCallback, getTransitionDurationFromElement(this._element));
        }
        _getConfig(config) {
            config = {
                ...Default$4,
                ...Manipulator.getDataAttributes(this._element),
                ...typeof config === "object" ? config : {}
            };
            typeCheckConfig(NAME$5, config, DefaultType$4);
            return config;
        }
        _enforceFocusOnElement(element) {
            EventHandler.off(document, EVENT_FOCUSIN); // guard against infinite focus loop
            EventHandler.on(document, EVENT_FOCUSIN, (event)=>{
                if (document !== event.target && element !== event.target && !element.contains(event.target)) element.focus();
            });
            element.focus();
        }
        _addEventListeners() {
            EventHandler.on(this._element, EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, ()=>this.hide());
            EventHandler.on(document, "keydown", (event)=>{
                if (this._config.keyboard && event.key === ESCAPE_KEY) this.hide();
            });
            EventHandler.on(document, EVENT_CLICK_DATA_API$1, (event)=>{
                const target = SelectorEngine.findOne(getSelectorFromElement(event.target));
                if (!this._element.contains(event.target) && target !== this._element) this.hide();
            });
        }
        static jQueryInterface(config) {
            return this.each(function() {
                const data = Data.get(this, DATA_KEY$5) || new Offcanvas(this, typeof config === "object" ? config : {});
                if (typeof config !== "string") return;
                if (data[config] === undefined || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
                data[config](this);
            });
        }
    }
    /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
        const target = getElementFromSelector(this);
        if ([
            "A",
            "AREA"
        ].includes(this.tagName)) event.preventDefault();
        if (isDisabled(this)) return;
        EventHandler.one(target, EVENT_HIDDEN$2, ()=>{
            // focus on trigger when it is closed
            if (isVisible(this)) this.focus();
        }); // avoid conflict when clicking a toggler of an offcanvas, while another is open
        const allReadyOpen = SelectorEngine.findOne(ACTIVE_SELECTOR);
        if (allReadyOpen && allReadyOpen !== target) return;
        const data = Data.get(target, DATA_KEY$5) || new Offcanvas(target);
        data.toggle(this);
    });
    EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{
        SelectorEngine.find(OPEN_SELECTOR).forEach((el)=>(Data.get(el, DATA_KEY$5) || new Offcanvas(el)).show());
    });
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */ defineJQueryPlugin(NAME$5, Offcanvas);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): util/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ const uriAttrs = new Set([
        "background",
        "cite",
        "href",
        "itemtype",
        "longdesc",
        "poster",
        "src",
        "xlink:href"
    ]);
    const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
    /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */ const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i;
    /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */ const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
    const allowedAttribute = (attr, allowedAttributeList)=>{
        const attrName = attr.nodeName.toLowerCase();
        if (allowedAttributeList.includes(attrName)) {
            if (uriAttrs.has(attrName)) return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));
            return true;
        }
        const regExp = allowedAttributeList.filter((attrRegex)=>attrRegex instanceof RegExp); // Check if a regular expression validates the attribute.
        for(let i = 0, len = regExp.length; i < len; i++){
            if (regExp[i].test(attrName)) return true;
        }
        return false;
    };
    const DefaultAllowlist = {
        // Global attributes allowed on any supplied element below.
        "*": [
            "class",
            "dir",
            "id",
            "lang",
            "role",
            ARIA_ATTRIBUTE_PATTERN
        ],
        a: [
            "target",
            "href",
            "title",
            "rel"
        ],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: [
            "src",
            "srcset",
            "alt",
            "title",
            "width",
            "height"
        ],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    };
    function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
        if (!unsafeHtml.length) return unsafeHtml;
        if (sanitizeFn && typeof sanitizeFn === "function") return sanitizeFn(unsafeHtml);
        const domParser = new window.DOMParser();
        const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
        const allowlistKeys = Object.keys(allowList);
        const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
        for(let i = 0, len = elements.length; i < len; i++){
            const el = elements[i];
            const elName = el.nodeName.toLowerCase();
            if (!allowlistKeys.includes(elName)) {
                el.parentNode.removeChild(el);
                continue;
            }
            const attributeList = [].concat(...el.attributes);
            const allowedAttributes = [].concat(allowList["*"] || [], allowList[elName] || []);
            attributeList.forEach((attr)=>{
                if (!allowedAttribute(attr, allowedAttributes)) el.removeAttribute(attr.nodeName);
            });
        }
        return createdDocument.body.innerHTML;
    }
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME$4 = "tooltip";
    const DATA_KEY$4 = "bs.tooltip";
    const EVENT_KEY$4 = `.${DATA_KEY$4}`;
    const CLASS_PREFIX$1 = "bs-tooltip";
    const BSCLS_PREFIX_REGEX$1 = new RegExp(`(^|\\s)${CLASS_PREFIX$1}\\S+`, "g");
    const DISALLOWED_ATTRIBUTES = new Set([
        "sanitize",
        "allowList",
        "sanitizeFn"
    ]);
    const DefaultType$3 = {
        animation: "boolean",
        template: "string",
        title: "(string|element|function)",
        trigger: "string",
        delay: "(number|object)",
        html: "boolean",
        selector: "(string|boolean)",
        placement: "(string|function)",
        offset: "(array|string|function)",
        container: "(string|element|boolean)",
        fallbackPlacements: "array",
        boundary: "(string|element)",
        customClass: "(string|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        allowList: "object",
        popperConfig: "(null|object|function)"
    };
    const AttachmentMap = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: isRTL() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: isRTL() ? "right" : "left"
    };
    const Default$3 = {
        animation: true,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        selector: false,
        placement: "top",
        offset: [
            0,
            0
        ],
        container: false,
        fallbackPlacements: [
            "top",
            "right",
            "bottom",
            "left"
        ],
        boundary: "clippingParents",
        customClass: "",
        sanitize: true,
        sanitizeFn: null,
        allowList: DefaultAllowlist,
        popperConfig: null
    };
    const Event$2 = {
        HIDE: `hide${EVENT_KEY$4}`,
        HIDDEN: `hidden${EVENT_KEY$4}`,
        SHOW: `show${EVENT_KEY$4}`,
        SHOWN: `shown${EVENT_KEY$4}`,
        INSERTED: `inserted${EVENT_KEY$4}`,
        CLICK: `click${EVENT_KEY$4}`,
        FOCUSIN: `focusin${EVENT_KEY$4}`,
        FOCUSOUT: `focusout${EVENT_KEY$4}`,
        MOUSEENTER: `mouseenter${EVENT_KEY$4}`,
        MOUSELEAVE: `mouseleave${EVENT_KEY$4}`
    };
    const CLASS_NAME_FADE$3 = "fade";
    const CLASS_NAME_MODAL = "modal";
    const CLASS_NAME_SHOW$3 = "show";
    const HOVER_STATE_SHOW = "show";
    const HOVER_STATE_OUT = "out";
    const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
    const TRIGGER_HOVER = "hover";
    const TRIGGER_FOCUS = "focus";
    const TRIGGER_CLICK = "click";
    const TRIGGER_MANUAL = "manual";
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class Tooltip extends BaseComponent {
        constructor(element, config){
            if (typeof Popper__namespace === "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            super(element); // private
            this._isEnabled = true;
            this._timeout = 0;
            this._hoverState = "";
            this._activeTrigger = {};
            this._popper = null; // Protected
            this.config = this._getConfig(config);
            this.tip = null;
            this._setListeners();
        }
        static get Default() {
            return Default$3;
        }
        static get NAME() {
            return NAME$4;
        }
        static get DATA_KEY() {
            return DATA_KEY$4;
        }
        static get Event() {
            return Event$2;
        }
        static get EVENT_KEY() {
            return EVENT_KEY$4;
        }
        static get DefaultType() {
            return DefaultType$3;
        }
        enable() {
            this._isEnabled = true;
        }
        disable() {
            this._isEnabled = false;
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled;
        }
        toggle(event) {
            if (!this._isEnabled) return;
            if (event) {
                const context = this._initializeOnDelegatedTarget(event);
                context._activeTrigger.click = !context._activeTrigger.click;
                if (context._isWithActiveTrigger()) context._enter(null, context);
                else context._leave(null, context);
            } else {
                if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$3)) {
                    this._leave(null, this);
                    return;
                }
                this._enter(null, this);
            }
        }
        dispose() {
            clearTimeout(this._timeout);
            EventHandler.off(this._element, this.constructor.EVENT_KEY);
            EventHandler.off(this._element.closest(`.${CLASS_NAME_MODAL}`), "hide.bs.modal", this._hideModalHandler);
            if (this.tip && this.tip.parentNode) this.tip.parentNode.removeChild(this.tip);
            this._isEnabled = null;
            this._timeout = null;
            this._hoverState = null;
            this._activeTrigger = null;
            if (this._popper) this._popper.destroy();
            this._popper = null;
            this.config = null;
            this.tip = null;
            super.dispose();
        }
        show() {
            if (this._element.style.display === "none") throw new Error("Please use show on visible elements");
            if (!(this.isWithContent() && this._isEnabled)) return;
            const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);
            const shadowRoot = findShadowRoot(this._element);
            const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);
            if (showEvent.defaultPrevented || !isInTheDom) return;
            const tip = this.getTipElement();
            const tipId = getUID(this.constructor.NAME);
            tip.setAttribute("id", tipId);
            this._element.setAttribute("aria-describedby", tipId);
            this.setContent();
            if (this.config.animation) tip.classList.add(CLASS_NAME_FADE$3);
            const placement = typeof this.config.placement === "function" ? this.config.placement.call(this, tip, this._element) : this.config.placement;
            const attachment = this._getAttachment(placement);
            this._addAttachmentClass(attachment);
            const container = this._getContainer();
            Data.set(tip, this.constructor.DATA_KEY, this);
            if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
                container.appendChild(tip);
                EventHandler.trigger(this._element, this.constructor.Event.INSERTED);
            }
            if (this._popper) this._popper.update();
            else this._popper = Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));
            tip.classList.add(CLASS_NAME_SHOW$3);
            const customClass = typeof this.config.customClass === "function" ? this.config.customClass() : this.config.customClass;
            if (customClass) tip.classList.add(...customClass.split(" "));
             // If this is a touch-enabled device we add extra
            // empty mouseover listeners to the body's immediate children;
            // only needed because of broken event delegation on iOS
            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
            if ("ontouchstart" in document.documentElement) [].concat(...document.body.children).forEach((element)=>{
                EventHandler.on(element, "mouseover", noop());
            });
            const complete = ()=>{
                const prevHoverState = this._hoverState;
                this._hoverState = null;
                EventHandler.trigger(this._element, this.constructor.Event.SHOWN);
                if (prevHoverState === HOVER_STATE_OUT) this._leave(null, this);
            };
            if (this.tip.classList.contains(CLASS_NAME_FADE$3)) {
                const transitionDuration = getTransitionDurationFromElement(this.tip);
                EventHandler.one(this.tip, "transitionend", complete);
                emulateTransitionEnd(this.tip, transitionDuration);
            } else complete();
        }
        hide() {
            if (!this._popper) return;
            const tip = this.getTipElement();
            const complete = ()=>{
                if (this._isWithActiveTrigger()) return;
                if (this._hoverState !== HOVER_STATE_SHOW && tip.parentNode) tip.parentNode.removeChild(tip);
                this._cleanTipClass();
                this._element.removeAttribute("aria-describedby");
                EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);
                if (this._popper) {
                    this._popper.destroy();
                    this._popper = null;
                }
            };
            const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);
            if (hideEvent.defaultPrevented) return;
            tip.classList.remove(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra
            // empty mouseover listeners we added for iOS support
            if ("ontouchstart" in document.documentElement) [].concat(...document.body.children).forEach((element)=>EventHandler.off(element, "mouseover", noop));
            this._activeTrigger[TRIGGER_CLICK] = false;
            this._activeTrigger[TRIGGER_FOCUS] = false;
            this._activeTrigger[TRIGGER_HOVER] = false;
            if (this.tip.classList.contains(CLASS_NAME_FADE$3)) {
                const transitionDuration = getTransitionDurationFromElement(tip);
                EventHandler.one(tip, "transitionend", complete);
                emulateTransitionEnd(tip, transitionDuration);
            } else complete();
            this._hoverState = "";
        }
        update() {
            if (this._popper !== null) this._popper.update();
        }
        isWithContent() {
            return Boolean(this.getTitle());
        }
        getTipElement() {
            if (this.tip) return this.tip;
            const element = document.createElement("div");
            element.innerHTML = this.config.template;
            this.tip = element.children[0];
            return this.tip;
        }
        setContent() {
            const tip = this.getTipElement();
            this.setElementContent(SelectorEngine.findOne(SELECTOR_TOOLTIP_INNER, tip), this.getTitle());
            tip.classList.remove(CLASS_NAME_FADE$3, CLASS_NAME_SHOW$3);
        }
        setElementContent(element, content) {
            if (element === null) return;
            if (typeof content === "object" && isElement(content)) {
                if (content.jquery) content = content[0];
                 // content is a DOM node or a jQuery
                if (this.config.html) {
                    if (content.parentNode !== element) {
                        element.innerHTML = "";
                        element.appendChild(content);
                    }
                } else element.textContent = content.textContent;
                return;
            }
            if (this.config.html) {
                if (this.config.sanitize) content = sanitizeHtml(content, this.config.allowList, this.config.sanitizeFn);
                element.innerHTML = content;
            } else element.textContent = content;
        }
        getTitle() {
            let title = this._element.getAttribute("data-bs-original-title");
            if (!title) title = typeof this.config.title === "function" ? this.config.title.call(this._element) : this.config.title;
            return title;
        }
        updateAttachment(attachment) {
            if (attachment === "right") return "end";
            if (attachment === "left") return "start";
            return attachment;
        }
        _initializeOnDelegatedTarget(event, context) {
            const dataKey = this.constructor.DATA_KEY;
            context = context || Data.get(event.delegateTarget, dataKey);
            if (!context) {
                context = new this.constructor(event.delegateTarget, this._getDelegateConfig());
                Data.set(event.delegateTarget, dataKey, context);
            }
            return context;
        }
        _getOffset() {
            const { offset: offset  } = this.config;
            if (typeof offset === "string") return offset.split(",").map((val)=>Number.parseInt(val, 10));
            if (typeof offset === "function") return (popperData)=>offset(popperData, this._element);
            return offset;
        }
        _getPopperConfig(attachment) {
            const defaultBsPopperConfig = {
                placement: attachment,
                modifiers: [
                    {
                        name: "flip",
                        options: {
                            altBoundary: true,
                            fallbackPlacements: this.config.fallbackPlacements
                        }
                    },
                    {
                        name: "offset",
                        options: {
                            offset: this._getOffset()
                        }
                    },
                    {
                        name: "preventOverflow",
                        options: {
                            boundary: this.config.boundary
                        }
                    },
                    {
                        name: "arrow",
                        options: {
                            element: `.${this.constructor.NAME}-arrow`
                        }
                    },
                    {
                        name: "onChange",
                        enabled: true,
                        phase: "afterWrite",
                        fn: (data)=>this._handlePopperPlacementChange(data)
                    }
                ],
                onFirstUpdate: (data)=>{
                    if (data.options.placement !== data.placement) this._handlePopperPlacementChange(data);
                }
            };
            return {
                ...defaultBsPopperConfig,
                ...typeof this.config.popperConfig === "function" ? this.config.popperConfig(defaultBsPopperConfig) : this.config.popperConfig
            };
        }
        _addAttachmentClass(attachment) {
            this.getTipElement().classList.add(`${CLASS_PREFIX$1}-${this.updateAttachment(attachment)}`);
        }
        _getContainer() {
            if (this.config.container === false) return document.body;
            if (isElement(this.config.container)) return this.config.container;
            return SelectorEngine.findOne(this.config.container);
        }
        _getAttachment(placement) {
            return AttachmentMap[placement.toUpperCase()];
        }
        _setListeners() {
            const triggers = this.config.trigger.split(" ");
            triggers.forEach((trigger)=>{
                if (trigger === "click") EventHandler.on(this._element, this.constructor.Event.CLICK, this.config.selector, (event)=>this.toggle(event));
                else if (trigger !== TRIGGER_MANUAL) {
                    const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
                    const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
                    EventHandler.on(this._element, eventIn, this.config.selector, (event)=>this._enter(event));
                    EventHandler.on(this._element, eventOut, this.config.selector, (event)=>this._leave(event));
                }
            });
            this._hideModalHandler = ()=>{
                if (this._element) this.hide();
            };
            EventHandler.on(this._element.closest(`.${CLASS_NAME_MODAL}`), "hide.bs.modal", this._hideModalHandler);
            if (this.config.selector) this.config = {
                ...this.config,
                trigger: "manual",
                selector: ""
            };
            else this._fixTitle();
        }
        _fixTitle() {
            const title = this._element.getAttribute("title");
            const originalTitleType = typeof this._element.getAttribute("data-bs-original-title");
            if (title || originalTitleType !== "string") {
                this._element.setAttribute("data-bs-original-title", title || "");
                if (title && !this._element.getAttribute("aria-label") && !this._element.textContent) this._element.setAttribute("aria-label", title);
                this._element.setAttribute("title", "");
            }
        }
        _enter(event, context) {
            context = this._initializeOnDelegatedTarget(event, context);
            if (event) context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {
                context._hoverState = HOVER_STATE_SHOW;
                return;
            }
            clearTimeout(context._timeout);
            context._hoverState = HOVER_STATE_SHOW;
            if (!context.config.delay || !context.config.delay.show) {
                context.show();
                return;
            }
            context._timeout = setTimeout(()=>{
                if (context._hoverState === HOVER_STATE_SHOW) context.show();
            }, context.config.delay.show);
        }
        _leave(event, context) {
            context = this._initializeOnDelegatedTarget(event, context);
            if (event) context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            if (context._isWithActiveTrigger()) return;
            clearTimeout(context._timeout);
            context._hoverState = HOVER_STATE_OUT;
            if (!context.config.delay || !context.config.delay.hide) {
                context.hide();
                return;
            }
            context._timeout = setTimeout(()=>{
                if (context._hoverState === HOVER_STATE_OUT) context.hide();
            }, context.config.delay.hide);
        }
        _isWithActiveTrigger() {
            for(const trigger in this._activeTrigger){
                if (this._activeTrigger[trigger]) return true;
            }
            return false;
        }
        _getConfig(config) {
            const dataAttributes = Manipulator.getDataAttributes(this._element);
            Object.keys(dataAttributes).forEach((dataAttr)=>{
                if (DISALLOWED_ATTRIBUTES.has(dataAttr)) delete dataAttributes[dataAttr];
            });
            if (config && typeof config.container === "object" && config.container.jquery) config.container = config.container[0];
            config = {
                ...this.constructor.Default,
                ...dataAttributes,
                ...typeof config === "object" && config ? config : {}
            };
            if (typeof config.delay === "number") config.delay = {
                show: config.delay,
                hide: config.delay
            };
            if (typeof config.title === "number") config.title = config.title.toString();
            if (typeof config.content === "number") config.content = config.content.toString();
            typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
            if (config.sanitize) config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
            return config;
        }
        _getDelegateConfig() {
            const config = {};
            if (this.config) {
                for(const key in this.config)if (this.constructor.Default[key] !== this.config[key]) config[key] = this.config[key];
            }
            return config;
        }
        _cleanTipClass() {
            const tip = this.getTipElement();
            const tabClass = tip.getAttribute("class").match(BSCLS_PREFIX_REGEX$1);
            if (tabClass !== null && tabClass.length > 0) tabClass.map((token)=>token.trim()).forEach((tClass)=>tip.classList.remove(tClass));
        }
        _handlePopperPlacementChange(popperData) {
            const { state: state  } = popperData;
            if (!state) return;
            this.tip = state.elements.popper;
            this._cleanTipClass();
            this._addAttachmentClass(this._getAttachment(state.placement));
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$4);
                const _config = typeof config === "object" && config;
                if (!data && /dispose|hide/.test(config)) return;
                if (!data) data = new Tooltip(this, _config);
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                    data[config]();
                }
            });
        }
    }
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Tooltip to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME$4, Tooltip);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME$3 = "popover";
    const DATA_KEY$3 = "bs.popover";
    const EVENT_KEY$3 = `.${DATA_KEY$3}`;
    const CLASS_PREFIX = "bs-popover";
    const BSCLS_PREFIX_REGEX = new RegExp(`(^|\\s)${CLASS_PREFIX}\\S+`, "g");
    const Default$2 = {
        ...Tooltip.Default,
        placement: "right",
        offset: [
            0,
            8
        ],
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
    };
    const DefaultType$2 = {
        ...Tooltip.DefaultType,
        content: "(string|element|function)"
    };
    const Event$1 = {
        HIDE: `hide${EVENT_KEY$3}`,
        HIDDEN: `hidden${EVENT_KEY$3}`,
        SHOW: `show${EVENT_KEY$3}`,
        SHOWN: `shown${EVENT_KEY$3}`,
        INSERTED: `inserted${EVENT_KEY$3}`,
        CLICK: `click${EVENT_KEY$3}`,
        FOCUSIN: `focusin${EVENT_KEY$3}`,
        FOCUSOUT: `focusout${EVENT_KEY$3}`,
        MOUSEENTER: `mouseenter${EVENT_KEY$3}`,
        MOUSELEAVE: `mouseleave${EVENT_KEY$3}`
    };
    const CLASS_NAME_FADE$2 = "fade";
    const CLASS_NAME_SHOW$2 = "show";
    const SELECTOR_TITLE = ".popover-header";
    const SELECTOR_CONTENT = ".popover-body";
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class Popover extends Tooltip {
        // Getters
        static get Default() {
            return Default$2;
        }
        static get NAME() {
            return NAME$3;
        }
        static get DATA_KEY() {
            return DATA_KEY$3;
        }
        static get Event() {
            return Event$1;
        }
        static get EVENT_KEY() {
            return EVENT_KEY$3;
        }
        static get DefaultType() {
            return DefaultType$2;
        }
        isWithContent() {
            return this.getTitle() || this._getContent();
        }
        setContent() {
            const tip = this.getTipElement(); // we use append for html objects to maintain js events
            this.setElementContent(SelectorEngine.findOne(SELECTOR_TITLE, tip), this.getTitle());
            let content = this._getContent();
            if (typeof content === "function") content = content.call(this._element);
            this.setElementContent(SelectorEngine.findOne(SELECTOR_CONTENT, tip), content);
            tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
        }
        _addAttachmentClass(attachment) {
            this.getTipElement().classList.add(`${CLASS_PREFIX}-${this.updateAttachment(attachment)}`);
        }
        _getContent() {
            return this._element.getAttribute("data-bs-content") || this.config.content;
        }
        _cleanTipClass() {
            const tip = this.getTipElement();
            const tabClass = tip.getAttribute("class").match(BSCLS_PREFIX_REGEX);
            if (tabClass !== null && tabClass.length > 0) tabClass.map((token)=>token.trim()).forEach((tClass)=>tip.classList.remove(tClass));
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$3);
                const _config = typeof config === "object" ? config : null;
                if (!data && /dispose|hide/.test(config)) return;
                if (!data) {
                    data = new Popover(this, _config);
                    Data.set(this, DATA_KEY$3, data);
                }
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                    data[config]();
                }
            });
        }
    }
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Popover to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME$3, Popover);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME$2 = "scrollspy";
    const DATA_KEY$2 = "bs.scrollspy";
    const EVENT_KEY$2 = `.${DATA_KEY$2}`;
    const DATA_API_KEY$1 = ".data-api";
    const Default$1 = {
        offset: 10,
        method: "auto",
        target: ""
    };
    const DefaultType$1 = {
        offset: "number",
        method: "string",
        target: "(string|element)"
    };
    const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
    const EVENT_SCROLL = `scroll${EVENT_KEY$2}`;
    const EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;
    const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
    const CLASS_NAME_ACTIVE$1 = "active";
    const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
    const SELECTOR_NAV_LIST_GROUP$1 = ".nav, .list-group";
    const SELECTOR_NAV_LINKS = ".nav-link";
    const SELECTOR_NAV_ITEMS = ".nav-item";
    const SELECTOR_LIST_ITEMS = ".list-group-item";
    const SELECTOR_DROPDOWN$1 = ".dropdown";
    const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
    const METHOD_OFFSET = "offset";
    const METHOD_POSITION = "position";
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class ScrollSpy extends BaseComponent {
        constructor(element, config){
            super(element);
            this._scrollElement = this._element.tagName === "BODY" ? window : this._element;
            this._config = this._getConfig(config);
            this._selector = `${this._config.target} ${SELECTOR_NAV_LINKS}, ${this._config.target} ${SELECTOR_LIST_ITEMS}, ${this._config.target} .${CLASS_NAME_DROPDOWN_ITEM}`;
            this._offsets = [];
            this._targets = [];
            this._activeTarget = null;
            this._scrollHeight = 0;
            EventHandler.on(this._scrollElement, EVENT_SCROLL, ()=>this._process());
            this.refresh();
            this._process();
        }
        static get Default() {
            return Default$1;
        }
        static get DATA_KEY() {
            return DATA_KEY$2;
        }
        refresh() {
            const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
            const offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
            const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
            this._offsets = [];
            this._targets = [];
            this._scrollHeight = this._getScrollHeight();
            const targets = SelectorEngine.find(this._selector);
            targets.map((element)=>{
                const targetSelector = getSelectorFromElement(element);
                const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;
                if (target) {
                    const targetBCR = target.getBoundingClientRect();
                    if (targetBCR.width || targetBCR.height) return [
                        Manipulator[offsetMethod](target).top + offsetBase,
                        targetSelector
                    ];
                }
                return null;
            }).filter((item)=>item).sort((a, b)=>a[0] - b[0]).forEach((item)=>{
                this._offsets.push(item[0]);
                this._targets.push(item[1]);
            });
        }
        dispose() {
            super.dispose();
            EventHandler.off(this._scrollElement, EVENT_KEY$2);
            this._scrollElement = null;
            this._config = null;
            this._selector = null;
            this._offsets = null;
            this._targets = null;
            this._activeTarget = null;
            this._scrollHeight = null;
        }
        _getConfig(config) {
            config = {
                ...Default$1,
                ...typeof config === "object" && config ? config : {}
            };
            if (typeof config.target !== "string" && isElement(config.target)) {
                let { id: id  } = config.target;
                if (!id) {
                    id = getUID(NAME$2);
                    config.target.id = id;
                }
                config.target = `#${id}`;
            }
            typeCheckConfig(NAME$2, config, DefaultType$1);
            return config;
        }
        _getScrollTop() {
            return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
        }
        _getScrollHeight() {
            return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        }
        _getOffsetHeight() {
            return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
        }
        _process() {
            const scrollTop = this._getScrollTop() + this._config.offset;
            const scrollHeight = this._getScrollHeight();
            const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
            if (this._scrollHeight !== scrollHeight) this.refresh();
            if (scrollTop >= maxScroll) {
                const target = this._targets[this._targets.length - 1];
                if (this._activeTarget !== target) this._activate(target);
                return;
            }
            if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
                this._activeTarget = null;
                this._clear();
                return;
            }
            for(let i = this._offsets.length; i--;){
                const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === "undefined" || scrollTop < this._offsets[i + 1]);
                if (isActiveTarget) this._activate(this._targets[i]);
            }
        }
        _activate(target) {
            this._activeTarget = target;
            this._clear();
            const queries = this._selector.split(",").map((selector)=>`${selector}[data-bs-target="${target}"],${selector}[href="${target}"]`);
            const link = SelectorEngine.findOne(queries.join(","));
            if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
                SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);
                link.classList.add(CLASS_NAME_ACTIVE$1);
            } else {
                // Set triggered link as active
                link.classList.add(CLASS_NAME_ACTIVE$1);
                SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach((listGroup)=>{
                    // Set triggered links parents as active
                    // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
                    SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach((item)=>item.classList.add(CLASS_NAME_ACTIVE$1)); // Handle special case when .nav-link is inside .nav-item
                    SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach((navItem)=>{
                        SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach((item)=>item.classList.add(CLASS_NAME_ACTIVE$1));
                    });
                });
            }
            EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {
                relatedTarget: target
            });
        }
        _clear() {
            SelectorEngine.find(this._selector).filter((node)=>node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach((node)=>node.classList.remove(CLASS_NAME_ACTIVE$1));
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY$2);
                const _config = typeof config === "object" && config;
                if (!data) data = new ScrollSpy(this, _config);
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                    data[config]();
                }
            });
        }
    }
    /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{
        SelectorEngine.find(SELECTOR_DATA_SPY).forEach((spy)=>new ScrollSpy(spy, Manipulator.getDataAttributes(spy)));
    });
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .ScrollSpy to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME$2, ScrollSpy);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME$1 = "tab";
    const DATA_KEY$1 = "bs.tab";
    const EVENT_KEY$1 = `.${DATA_KEY$1}`;
    const DATA_API_KEY = ".data-api";
    const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
    const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
    const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
    const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
    const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;
    const CLASS_NAME_DROPDOWN_MENU = "dropdown-menu";
    const CLASS_NAME_ACTIVE = "active";
    const CLASS_NAME_FADE$1 = "fade";
    const CLASS_NAME_SHOW$1 = "show";
    const SELECTOR_DROPDOWN = ".dropdown";
    const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
    const SELECTOR_ACTIVE = ".active";
    const SELECTOR_ACTIVE_UL = ":scope > li > .active";
    const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
    const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
    const SELECTOR_DROPDOWN_ACTIVE_CHILD = ":scope > .dropdown-menu .active";
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class Tab extends BaseComponent {
        // Getters
        static get DATA_KEY() {
            return DATA_KEY$1;
        }
        show() {
            if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE) || isDisabled(this._element)) return;
            let previous;
            const target = getElementFromSelector(this._element);
            const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);
            if (listElement) {
                const itemSelector = listElement.nodeName === "UL" || listElement.nodeName === "OL" ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
                previous = SelectorEngine.find(itemSelector, listElement);
                previous = previous[previous.length - 1];
            }
            const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {
                relatedTarget: this._element
            }) : null;
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {
                relatedTarget: previous
            });
            if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) return;
            this._activate(this._element, listElement);
            const complete = ()=>{
                EventHandler.trigger(previous, EVENT_HIDDEN$1, {
                    relatedTarget: this._element
                });
                EventHandler.trigger(this._element, EVENT_SHOWN$1, {
                    relatedTarget: previous
                });
            };
            if (target) this._activate(target, target.parentNode, complete);
            else complete();
        }
        _activate(element, container, callback) {
            const activeElements = container && (container.nodeName === "UL" || container.nodeName === "OL") ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);
            const active = activeElements[0];
            const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);
            const complete = ()=>this._transitionComplete(element, active, callback);
            if (active && isTransitioning) {
                const transitionDuration = getTransitionDurationFromElement(active);
                active.classList.remove(CLASS_NAME_SHOW$1);
                EventHandler.one(active, "transitionend", complete);
                emulateTransitionEnd(active, transitionDuration);
            } else complete();
        }
        _transitionComplete(element, active, callback) {
            if (active) {
                active.classList.remove(CLASS_NAME_ACTIVE);
                const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);
                if (dropdownChild) dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
                if (active.getAttribute("role") === "tab") active.setAttribute("aria-selected", false);
            }
            element.classList.add(CLASS_NAME_ACTIVE);
            if (element.getAttribute("role") === "tab") element.setAttribute("aria-selected", true);
            reflow(element);
            if (element.classList.contains(CLASS_NAME_FADE$1)) element.classList.add(CLASS_NAME_SHOW$1);
            if (element.parentNode && element.parentNode.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
                const dropdownElement = element.closest(SELECTOR_DROPDOWN);
                if (dropdownElement) SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE).forEach((dropdown)=>dropdown.classList.add(CLASS_NAME_ACTIVE));
                element.setAttribute("aria-expanded", true);
            }
            if (callback) callback();
        }
        static jQueryInterface(config) {
            return this.each(function() {
                const data = Data.get(this, DATA_KEY$1) || new Tab(this);
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                    data[config]();
                }
            });
        }
    }
    /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
        event.preventDefault();
        const data = Data.get(this, DATA_KEY$1) || new Tab(this);
        data.show();
    });
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Tab to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME$1, Tab);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): toast.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */ const NAME = "toast";
    const DATA_KEY = "bs.toast";
    const EVENT_KEY = `.${DATA_KEY}`;
    const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;
    const EVENT_HIDE = `hide${EVENT_KEY}`;
    const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
    const EVENT_SHOW = `show${EVENT_KEY}`;
    const EVENT_SHOWN = `shown${EVENT_KEY}`;
    const CLASS_NAME_FADE = "fade";
    const CLASS_NAME_HIDE = "hide";
    const CLASS_NAME_SHOW = "show";
    const CLASS_NAME_SHOWING = "showing";
    const DefaultType = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    };
    const Default = {
        animation: true,
        autohide: true,
        delay: 5000
    };
    const SELECTOR_DATA_DISMISS = '[data-bs-dismiss="toast"]';
    /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */ class Toast extends BaseComponent {
        constructor(element, config){
            super(element);
            this._config = this._getConfig(config);
            this._timeout = null;
            this._setListeners();
        }
        static get DefaultType() {
            return DefaultType;
        }
        static get Default() {
            return Default;
        }
        static get DATA_KEY() {
            return DATA_KEY;
        }
        show() {
            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
            if (showEvent.defaultPrevented) return;
            this._clearTimeout();
            if (this._config.animation) this._element.classList.add(CLASS_NAME_FADE);
            const complete = ()=>{
                this._element.classList.remove(CLASS_NAME_SHOWING);
                this._element.classList.add(CLASS_NAME_SHOW);
                EventHandler.trigger(this._element, EVENT_SHOWN);
                if (this._config.autohide) this._timeout = setTimeout(()=>{
                    this.hide();
                }, this._config.delay);
            };
            this._element.classList.remove(CLASS_NAME_HIDE);
            reflow(this._element);
            this._element.classList.add(CLASS_NAME_SHOWING);
            if (this._config.animation) {
                const transitionDuration = getTransitionDurationFromElement(this._element);
                EventHandler.one(this._element, "transitionend", complete);
                emulateTransitionEnd(this._element, transitionDuration);
            } else complete();
        }
        hide() {
            if (!this._element.classList.contains(CLASS_NAME_SHOW)) return;
            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
            if (hideEvent.defaultPrevented) return;
            const complete = ()=>{
                this._element.classList.add(CLASS_NAME_HIDE);
                EventHandler.trigger(this._element, EVENT_HIDDEN);
            };
            this._element.classList.remove(CLASS_NAME_SHOW);
            if (this._config.animation) {
                const transitionDuration = getTransitionDurationFromElement(this._element);
                EventHandler.one(this._element, "transitionend", complete);
                emulateTransitionEnd(this._element, transitionDuration);
            } else complete();
        }
        dispose() {
            this._clearTimeout();
            if (this._element.classList.contains(CLASS_NAME_SHOW)) this._element.classList.remove(CLASS_NAME_SHOW);
            EventHandler.off(this._element, EVENT_CLICK_DISMISS);
            super.dispose();
            this._config = null;
        }
        _getConfig(config) {
            config = {
                ...Default,
                ...Manipulator.getDataAttributes(this._element),
                ...typeof config === "object" && config ? config : {}
            };
            typeCheckConfig(NAME, config, this.constructor.DefaultType);
            return config;
        }
        _setListeners() {
            EventHandler.on(this._element, EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, ()=>this.hide());
        }
        _clearTimeout() {
            clearTimeout(this._timeout);
            this._timeout = null;
        }
        static jQueryInterface(config) {
            return this.each(function() {
                let data = Data.get(this, DATA_KEY);
                const _config = typeof config === "object" && config;
                if (!data) data = new Toast(this, _config);
                if (typeof config === "string") {
                    if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                    data[config](this);
                }
            });
        }
    }
    /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Toast to jQuery only if jQuery is present
   */ defineJQueryPlugin(NAME, Toast);
    /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.0.0-beta3): index.umd.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ var index_umd = {
        Alert: Alert,
        Button: Button,
        Carousel: Carousel,
        Collapse: Collapse,
        Dropdown: Dropdown,
        Modal: Modal,
        Offcanvas: Offcanvas,
        Popover: Popover,
        ScrollSpy: ScrollSpy,
        Tab: Tab,
        Toast: Toast,
        Tooltip: Tooltip
    };
    return index_umd;
}); //# sourceMappingURL=bootstrap.js.map


//# sourceMappingURL=index.150f890e.js.map